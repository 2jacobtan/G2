-- This module generates functions in the expr_env that walk over the whole structure of an ADT.
-- This forces evaluation of the ADT

module G2.Internals.Initialization.CreateWalks ( createWalks
                                               , createDeepSeqWalks
                                               , createContainedTypeWalks) where

import G2.Internals.Language
import qualified G2.Internals.Language.ExprEnv as E

import Data.List
import qualified Data.Map as M
import Data.Maybe

type NameGenFunc a = a -> Name
type ExprGenFunc a b = NameGen -> [(a, Name, b)] -> a -> b -> (Expr, NameGen)
type StoreGenFunc a b c = c -> a -> b -> Name -> Expr -> c

-- | createWalks
-- Given some [(a, b)], and functions to convert a's to Names and b's to Exprs, creates
-- new functions with the given Names and Exprs
-- The function returned by the name function will always be fed through a NameGen,
-- so it will not conflict with anything in the environment
-- The [(Name, b)] given to the Expr generating function is the created mapping from Names to b's
-- We also take a c, and a function to allow storing some information about the generated functions
-- in that c.
createWalks :: ExprEnv -> NameGen
            -> [(a, b)]
            -> c 
            -> NameGenFunc a
            -> ExprGenFunc a b
            -> StoreGenFunc a b c
            -> (ExprEnv, NameGen, c)
createWalks eenv ng xs store fn fe fs =
    let
        (ns, ng') = freshSeededNames (map (fn . fst) xs) ng

        xsFst = map fst xs
        xsSnd = map snd xs

        (eenv', ng'', store') =
            createWalks' eenv ng' (zip3 xsFst ns xsSnd) (zip3 xsFst ns xsSnd) store fe fs
    in
    (eenv', ng'', store')

createWalks' :: ExprEnv -> NameGen 
             -> [(a, Name, b)]
             -> [(a, Name, b)]
             -> c
             -> ExprGenFunc a b
             -> StoreGenFunc a b c
             -> (ExprEnv, NameGen, c)
createWalks' eenv ng _ [] store _ _ = (eenv, ng, store)
createWalks' eenv ng ne ((x, n, y):xs) store fe fs =
    let
        (eenv', ng', store') = createWalk eenv ng ne n x y store fe fs
    in
    createWalks' eenv' ng' ne xs store' fe fs

createWalk :: ExprEnv -> NameGen
           -> [(a, Name, b)]
           -> Name
           -> a -> b -> c
           -> ExprGenFunc a b
           -> StoreGenFunc a b c
           -> (ExprEnv, NameGen, c)
createWalk eenv ng ne n x y store fe fs =
    let
        (e, ng') = fe ng ne x y
        eenv' = E.insert n e eenv

        store' = fs store x y n e
    in
    (eenv', ng', store')

-- | createAlgDataTyWalks
-- A special case of createWalk where the function names are generated by
-- appending to each ADT type name, the expressions are generated from the type
-- names and the cooresponding AlgDataTy's, and the results are stored
-- in a Walkers Map
createAlgDataTyWalks :: ExprEnv -> TypeEnv -> NameGen
                     -> String
                     -> (DataCon -> [(Name, Name, AlgDataTy)] -> NameGen -> Id -> (Maybe Alt, NameGen))
                     -> StoreGenFunc Name AlgDataTy Walkers
                     -> (ExprEnv, NameGen, Walkers)
createAlgDataTyWalks eenv tenv ng s fe fs  =
    let
        tenv_list = M.toList tenv

        (eenv', ng', w) = createWalks eenv ng tenv_list M.empty
                            (createAlgDataTyWalkName s) (createAlgDataTyWalkExpr fe) fs
    in
    (eenv', ng', w)

createAlgDataTyWalkName :: String -> Name -> Name
createAlgDataTyWalkName s (Name n _ _) = Name (s ++ n) Nothing 0

createAlgDataTyWalkExpr :: (DataCon -> [(Name, Name, AlgDataTy)] -> NameGen -> Id -> (Maybe Alt, NameGen))
                        -> NameGen -> [(Name, Name, AlgDataTy)] -> Name
                        -> AlgDataTy
                        -> (Expr, NameGen)
createAlgDataTyWalkExpr fa ng nm tn (AlgDataTy _ dc) =
    let        
        (l_bind_id, ng2) = freshId (TyConApp tn []) ng
        l_var = Var l_bind_id

        (c_bind_id, ng3) = freshId (TyConApp tn []) ng2

        (alts, ng4) = createAlgDataTyWalkAlt fa dc nm ng3 c_bind_id

        c = Lam l_bind_id $ Case l_var c_bind_id alts
    in
    (c, ng4)

createAlgDataTyWalkAlt ::
    (DataCon -> [(Name, Name, AlgDataTy)] -> NameGen -> Id -> (Maybe Alt, NameGen))
    -> [DataCon]
    -> [(Name, Name, AlgDataTy)]
    -> NameGen
    -> Id
    -> ([Alt], NameGen)
createAlgDataTyWalkAlt _ [] _ ng _ = ([], ng)
createAlgDataTyWalkAlt f (dc:dcs) nm ng i =
    let
        (a, ng') = f dc nm ng i
        (as, ng'') = createAlgDataTyWalkAlt f dcs nm ng' i
    in
    case a of
        Just a' -> (a':as, ng'')
        Nothing -> (as, ng'')

-- | createDeepSeqWalks
-- This generates functions that walk over the whole structure of an ADT.
-- This forces evaluation of the ADT
createDeepSeqWalks :: ExprEnv -> TypeEnv -> NameGen -> (ExprEnv, NameGen, Walkers)
createDeepSeqWalks eenv tenv ng =
    createAlgDataTyWalks eenv tenv ng "walk" (\dc nna ng' _ -> fstDataConAltMatch dc nna ng') storeWalkerFunc

-- The (Name, Name, AlgDataTy) tuples are the type name, the walking function name, and the AlgDataTyName
fstDataConAltMatch :: DataCon -> [(Name, Name, AlgDataTy)] -> NameGen -> (Maybe Alt, NameGen)
fstDataConAltMatch dc@(DataCon _ _ ts) ns ng =
    let
        (arg_names, ng1) = freshNames (length ts) ng
        arg_ids = map (uncurry Id) (zip arg_names ts)

        am = DataAlt dc arg_ids
        (e, ng3) = sndDataConAltMatch arg_ids ng1 ns (Data dc)

        alt = Alt am e
    in
    (Just alt, ng3)
fstDataConAltMatch _ _ ng = (Nothing, ng)

sndDataConAltMatch :: [Id] -> NameGen -> [(Name, Name, AlgDataTy)] ->  Expr -> (Expr, NameGen)
sndDataConAltMatch [] ng _ dc = (dc, ng)
sndDataConAltMatch (i@(Id _ t):xs) ng ns dc =
    let
        (b_id, ng') = freshId t ng

        case_e = case t of
                    TyConApp n' _ ->
                        let
                            (t', w, _) = fromJust $ find (\(t'', _, _) -> t'' == n') ns
                            f = walkFunc t' w
                        in
                        Case (App (Var f) (Var i)) b_id
                    _ -> Case (Var i) b_id

        dc' = App dc (Var b_id)

        (e, ng'') = sndDataConAltMatch xs ng' ns dc'

        am = [Alt Default e]
    in
    (case_e am, ng'')

-- Type Name -> Walk function name -> Walk Function Id
walkFunc :: Name -> Name -> Id
walkFunc t w = Id w (TyFun (TyConApp t []) (TyConApp t []))

storeWalkerFunc :: Walkers -> Name -> AlgDataTy -> Name -> Expr -> Walkers
storeWalkerFunc w tn _ fn _ =
    let
         i = walkFunc tn fn
    in
    M.insert tn i w

-- | createContainedTypeWalks
-- Creates functions that walk over a polymorphic ADT D t_1 .. t_n, with type:
--      f :: (t_1 -> Bool) -> ... -> (t_n -> Bool) -> d -> Bool 
--      f p_1 ... p_n d
-- The predicate p_i is run on every value of type t_i, and the conjunction is returned
createContainedTypeWalks :: ExprEnv -> TypeEnv -> NameGen -> (ExprEnv, NameGen, Walkers)
createContainedTypeWalks eenv tenv ng =
    createAlgDataTyWalks eenv tenv ng "containType" undefined undefined