-- This module generates functions in the expr_env that walk over the whole structure of an ADT.
-- This forces evaluation of the ADT

module G2.Internals.Initialization.CreateFuncs ( createFuncs
                                               , createFunc
                                               , createDeepSeqWalks
                                               , createPolyPredWalks
                                               , createHigherOrderWrappers ) where

import G2.Internals.Language
import qualified G2.Internals.Language.ExprEnv as E

import Data.List
import qualified Data.Map as M
import Data.Maybe

type NameGenFunc a = a -> Name
type ExprGenFunc a b = NameGen -> [(a, Name, b)] -> a -> b -> (Expr, NameGen)
type StoreGenFunc a b c = c -> a -> b -> Name -> Expr -> c

-- | createFuncs
-- Given some [(a, b)], and functions to convert a's to Names and b's to Exprs, creates
-- new functions with the given Names and Exprs
-- The function returned by the name function will always be fed through a NameGen,
-- so it will not conflict with anything in the environment
-- The [(Name, b)] given to the Expr generating function is the created mapping from Names to b's
-- We also take a c, and a function to allow storing some information about the generated functions
-- in that c.
createFuncs :: ExprEnv -> NameGen
            -> [(a, b)]
            -> c 
            -> NameGenFunc a
            -> ExprGenFunc a b
            -> StoreGenFunc a b c
            -> (ExprEnv, NameGen, c)
createFuncs eenv ng xs store fn fe fs =
    let
        (ns, ng') = freshSeededNames (map (fn . fst) xs) ng

        xsFst = map fst xs
        xsSnd = map snd xs

        (eenv', ng'', store') =
            createFuncs' eenv ng' (zip3 xsFst ns xsSnd) (zip3 xsFst ns xsSnd) store fe fs
    in
    (eenv', ng'', store')

createFuncs' :: ExprEnv -> NameGen 
             -> [(a, Name, b)]
             -> [(a, Name, b)]
             -> c
             -> ExprGenFunc a b
             -> StoreGenFunc a b c
             -> (ExprEnv, NameGen, c)
createFuncs' eenv ng _ [] store _ _ = (eenv, ng, store)
createFuncs' eenv ng ne ((x, n, y):xs) store fe fs =
    let
        (eenv', ng', store') = createFunc eenv ng ne n x y store fe fs
    in
    createFuncs' eenv' ng' ne xs store' fe fs

createFunc :: ExprEnv -> NameGen
           -> [(a, Name, b)]
           -> Name
           -> a -> b -> c
           -> ExprGenFunc a b
           -> StoreGenFunc a b c
           -> (ExprEnv, NameGen, c)
createFunc eenv ng ne n x y store fe fs =
    let
        (e, ng') = fe ng ne x y
        eenv' = E.insert n e eenv

        store' = fs store x y n e
    in
    (eenv', ng', store')

-- Types for createAlgDataTyWalks
type AltFunc a = DataCon -- The DataCon being pattern match on
               -> [(Name, Name, AlgDataTy)]
               -> NameGen
               -> Id -- The Case binder
               -> [Id] -- Binders for each DataCon argument
               -> [(a, Id)] -- The non datacon arguments
               -> (Maybe Expr, NameGen)

type DefaultFunc a = [(Name, Name, AlgDataTy)] -> NameGen -> Id -> [(a, Id)] -> (Expr, NameGen)

-- | createAlgDataTyWalks
-- A special case of createFunc where the function names are generated by
-- appending to each ADT type name, the expressions are generated from the type
-- names and the cooresponding AlgDataTy's, and the results are stored
-- in a Walkers Map
createAlgDataTyWalks :: ExprEnv -> TypeEnv -> NameGen
                     -> (AlgDataTy -> [(a, Maybe Name, Type)]) -- Other arguments that should be considered
                     -> String -- A string to append to a DC Name, to create a new function name
                     -> AltFunc a -- Maybe creates an Alt for each DC
                     -> DefaultFunc a -- Creates an Expr for a Default DC
                     -> StoreGenFunc Name AlgDataTy Walkers
                     -> (ExprEnv, NameGen, Walkers)
createAlgDataTyWalks eenv tenv ng falg s fe fd fs  =
    let
        tenv_list = M.toList tenv

        (eenv', ng', w) = createFuncs eenv ng tenv_list M.empty
                            (createAlgDataTyWalkName s) 
                            (createAlgDataTyWalkExpr falg fe fd)
                            fs
    in
    (eenv', ng', w)

createAlgDataTyWalkName :: String -> Name -> Name
createAlgDataTyWalkName s (Name n _ _) = Name (s ++ n) None 0


createAlgDataTyWalkExpr :: (AlgDataTy -> [(a, Maybe Name, Type)])
                        -> AltFunc a
                        -> DefaultFunc a
                        -> NameGen -> [(Name, Name, AlgDataTy)] -> Name
                        -> AlgDataTy
                        -> (Expr, NameGen)
createAlgDataTyWalkExpr falg fa fd ng nm tn adt@(AlgDataTy _ _) =
    let
        arg_ty = falg adt
    in
    mkLamBindings ng arg_ty $ \ng' ids -> createAlgDataTyWalkExpr' fa fd ng' nm tn adt ids

createAlgDataTyWalkExpr' :: AltFunc a
                        -> DefaultFunc a
                        -> NameGen -> [(Name, Name, AlgDataTy)] -> Name
                        -> AlgDataTy
                        -> [(a, Id)]
                        -> (Expr, NameGen)
createAlgDataTyWalkExpr' fa fd ng nm tn (AlgDataTy _ dc) is =
    let        
        (l_bind_id, ng2) = freshId (TyConApp tn []) ng
        l_var = Var l_bind_id

        (c_bind_id, ng3) = freshId (TyConApp tn []) ng2

        (defExpr, ng4) = fd nm ng3 c_bind_id is
        def = Alt Default defExpr

        (alts, ng5) = createAlgDataTyWalkAlt fa dc nm ng4 c_bind_id is

        c = Lam l_bind_id $ Case l_var c_bind_id (def:alts)
    in
    (c, ng5)

createAlgDataTyWalkAlt ::
    AltFunc a
    -> [DataCon]
    -> [(Name, Name, AlgDataTy)]
    -> NameGen
    -> Id
    -> [(a, Id)]
    -> ([Alt], NameGen)
createAlgDataTyWalkAlt _ [] _ ng _ _  = ([], ng)
createAlgDataTyWalkAlt f (dc@(DataCon _ _ ts):dcs) nm ng i ids =
    let
        (arg_ids, ng2) = freshIds ts ng

        (e, ng3) = f dc nm ng2 i arg_ids ids
        (as, ng4) = createAlgDataTyWalkAlt f dcs nm ng3 i ids

        am = DataAlt dc arg_ids
    in
    case e of
        Just e' -> (Alt am e':as, ng4)
        Nothing -> (as, ng4)
createAlgDataTyWalkAlt _ (PrimCon _:_) _ _ _ _ = error "PrimCon in createAlgDataTyWalkAlt"

storeWalkerFunc :: Walkers -> Name -> AlgDataTy -> Name -> Expr -> Walkers
storeWalkerFunc w tn _ fn e =
    let
         i = Id fn (typeOf e)-- walkFunc tn fn
    in
    M.insert tn i w



-- | createDeepSeqWalks
-- This generates functions that walk over the whole structure of an ADT.
-- This forces evaluation of the ADT
createDeepSeqWalks :: ExprEnv -> TypeEnv -> NameGen -> (ExprEnv, NameGen, Walkers)
createDeepSeqWalks eenv tenv ng =
    createAlgDataTyWalks eenv tenv ng (const []) "walk" 
        (\dc nna ng' _ is _ -> createDeepSeqExpr dc nna ng' is)
        (\_ ng' i _ -> (Var i, ng'))
        storeWalkerFunc

-- The (Name, Name, AlgDataTy) tuples are the type name, the walking function
-- name, and the AlgDataTyName
createDeepSeqExpr :: DataCon -> [(Name, Name, AlgDataTy)] -> NameGen -> [Id] -> (Maybe Expr, NameGen)
createDeepSeqExpr dc@(DataCon _ _ _) ns ng arg_ids =
    let
        (e, ng2) = createDeepSeqExpr' (Data dc) ns ng arg_ids
    in
    (Just e, ng2)
createDeepSeqExpr _ _ ng _ = (Nothing, ng)

createDeepSeqExpr' :: Expr -> [(Name, Name, AlgDataTy)] -> NameGen -> [Id] -> (Expr, NameGen)
createDeepSeqExpr' dc _ ng [] = (dc, ng)
createDeepSeqExpr' dc ns ng (i@(Id _ t):xs)=
    let
        (b_id, ng') = freshId t ng

        case_e = case t of
                    TyConApp n' _ ->
                        let
                            (t', w, _) = fromJust $ find (\(t'', _, _) -> t'' == n') ns
                            f = walkFunc t' w
                        in
                        Case (App (Var f) (Var i)) b_id
                    _ -> Case (Var i) b_id

        dc' = App dc (Var b_id)

        (e, ng'') = createDeepSeqExpr' dc' ns ng' xs

        am = [Alt Default e]
    in
    (case_e am, ng'')

-- Type Name -> Walk function name -> Walk Function Id
walkFunc :: Name -> Name -> Id
walkFunc t w = Id w (TyFun (TyConApp t []) (TyConApp t []))



-- | createPolyPredWalks
-- Creates functions that walk over a polymorphic ADT D t_1 ... t_n, with type:
--      f :: (t_1 -> Bool) -> ... -> (t_n -> Bool) -> d -> Bool 
--      f p_1 ... p_n d
-- The predicate p_i is run on every value of type t_i, and the conjunction is returned
createPolyPredWalks :: ExprEnv -> TypeEnv -> NameGen -> (ExprEnv, NameGen, Walkers)
createPolyPredWalks eenv tenv ng =
    let
        poly_tenv = M.filter isPolyAlgDataTy tenv
    in
    createAlgDataTyWalks eenv poly_tenv ng
        (createPolyPredArgs)
        "polyPred"
        (createPolyPredAlt eenv)
        (\_ ng' i _ -> (Var i, ng'))
        storeWalkerFunc

createPolyPredArgs :: AlgDataTy -> [(Maybe Name, Maybe Name, Type)]
createPolyPredArgs (AlgDataTy ns _) =
    map (\n -> (Nothing, Just n, TYPE)) ns 
    ++ map (\n -> (Just n, Nothing, TyFun (TyVar $ Id n TYPE) (TyBool))) ns

createPolyPredAlt :: ExprEnv -> DataCon -> [(Name, Name, AlgDataTy)] -> NameGen -> Id -> [Id] -> [(Maybe Name, Id)] -> (Maybe Expr, NameGen)
createPolyPredAlt eenv (DataCon _ t _) _ ng _ dcs is = 
    let
        (e, ng2) = createPolyPredAlt' eenv dcs ng is
    in
    case polyIds t of
        [] -> (Nothing, ng)
        _ -> (Just e, ng2)
createPolyPredAlt _ (PrimCon _) _ _ _ _ _ = error "PrimCon in createPolyPredAlt"

createPolyPredAlt' :: ExprEnv -> [Id] -> NameGen -> [(Maybe Name, Id)] -> (Expr, NameGen)
createPolyPredAlt' eenv dcpat ng is =
    let
        predApps = mapMaybe (createPolyPredAlt'' is) dcpat
    in
    (foldr (\e e' -> App (
                            App (mkAnd eenv)
                            e
                        ) e') (mkTrue) predApps, ng)

createPolyPredAlt'' :: [(Maybe Name, Id)] -> Id -> Maybe Expr
createPolyPredAlt'' typePreds i@(Id _ (TyVar (Id n _))) =
    case lookup (Just n) typePreds of
        Just f -> Just $ App (Var f) (Var i)
        Nothing -> Nothing
createPolyPredAlt'' _ _ = Nothing



-- | createHigherOrderWrapper
-- This generates function to impose asserts on the input and output of higher
-- order functions.  For each function in a higher order function signature:
--      f :: (a_1 -> ... -> a_n -> b) -> ... -> c
-- we autogenerate a function:
--      wrapper :: (a_1 -> ... -> a_n -> b -> Bool)
--              -> (a_1 -> ... -> a_n -> b) -> a_1 -> ... -> a_n -> b
createHigherOrderWrappers :: ExprEnv -> TypeEnv -> NameGen -> (ExprEnv, NameGen, Wrappers)
createHigherOrderWrappers eenv tenv ng =
    let
        types = nub $ argTypesTEnv tenv ++ E.higherOrderExprs eenv
    in
    createFuncs eenv ng (zip (repeat ()) types) []
        (const $ Name "wrapper" None 0)
        createHigherOrderWrapperExpr
        storeWrapper

createHigherOrderWrapperExpr :: NameGen -> [((), Name, Type)] -> () -> Type -> (Expr, NameGen)
createHigherOrderWrapperExpr ng _ _ t =
    let
        predType = appendType t TyBool

        wrapperT = [(Just "pred", Nothing, predType), (Just "higher", Nothing, t)]
                   ++ zip3 (repeat Nothing) (repeat Nothing) (init $ splitTyFuns t)
    in
    mkLamBindings ng wrapperT $ \ng' wr -> createHigherOrderWrapperExpr' ng' wr

createHigherOrderWrapperExpr' :: NameGen -> [(Maybe String, Id)] -> (Expr, NameGen)
createHigherOrderWrapperExpr' ng ts' =
    let
        pre:higher:ts = map snd ts'

        higherCall = mkApp . map Var $ higher:ts

        (higherId, ng') = freshId (typeOf higherCall) ng

        predCall = mkApp . map Var $ pre:ts ++ [higherId]

        a = Assume predCall (Var higherId)

        letExpr = Let [(higherId, higherCall)] a
    in
    (letExpr, ng')

storeWrapper :: Wrappers -> () -> Type -> Name -> Expr -> Wrappers
storeWrapper w _ t n e = (t, Id n (typeOf e)):w