module G2.Internals.Execution.Support
    ( ExecState(..)
    , fromState
    , toState

    , ExecStack
    , Frame(..)
    , ExprEnv

    , pushExecStack
    , popExecStack
    , execStackToList

    , renameExecState
    , renamings
    ) where

import G2.Internals.Language.ExprEnv
import G2.Internals.Language

import qualified Data.Map as M

-- | The execution state that we keep track of is different than the regular
-- G2 state. This is because for execution we need more complicated data
-- structures to make things more run smoothly in the rule reductions. However
-- there are `fromState` and `toState` functions provided to extract and inject
-- back the original values from `State`.
data ExecState = ExecState { exec_stack :: ExecStack
                           , exec_eenv :: ExprEnv
                           , exec_code :: CurrExpr
                           , exec_names :: NameGen
                           , exec_paths :: [PathCond]
                           } deriving (Show, Eq, Read)

-- | `State` to `ExecState`.
fromState :: State -> ExecState
fromState State { expr_env = eenv
                , curr_expr = expr
                , name_gen = confs
                , path_conds = paths } = exec_state
  where
    exec_state = ExecState { exec_stack = ExecStack []
                           , exec_eenv = eenv
                           , exec_code = expr
                           , exec_names = confs
                           , exec_paths = paths }

-- | `ExecState` to `State`.
toState :: State -> ExecState -> State
toState s e_s = State { expr_env = undefined
                      , type_env = type_env s
                      , curr_expr = exec_code e_s
                      , name_gen = name_gen s
                      , path_conds = undefined
                      , sym_links = sym_links s
                      , func_table = func_table s }

-- | The reason hy Haskell does not enable stack traces by default is because
-- the notion of a function call stack does not really exist in Haskell. The
-- stack is a combination of update pointers, application frames, and other
-- stuff!
newtype ExecStack = ExecStack [Frame] deriving (Show, Eq, Read)

-- | These are stack frames.
-- * Case frames contain an `Id` for which to bind the inspection expression,
--     a list of `Alt`, and a `ExecExprEnv` in which this `CaseFrame` happened.
--     `CaseFrame`s are generated as a result of evaluating `Case` expressions.
-- * Application frames contain a single expression and its `ExecExprEnv`.
--     These are generated by `App` expressions.
-- * Update frames contain the `Name` on which to inject a new thing into the
--     expression environment after the current expression is done evaluating.
data Frame = CaseFrame Id [Alt]
           | ApplyFrame Expr
           | UpdateFrame Name
           deriving (Show, Eq, Read)

-- | Push a `Frame` onto the `ExecStack`.
pushExecStack :: Frame -> ExecStack -> ExecStack
pushExecStack frame (ExecStack frames) = ExecStack (frame : frames)

-- | Pop a `Frame` from the `ExecStack`, should it exist.
popExecStack :: ExecStack -> Maybe (Frame, ExecStack)
popExecStack (ExecStack []) = Nothing
popExecStack (ExecStack (frame:frames)) = Just (frame, ExecStack frames)

-- | Convert an `ExecStack` to a list.
execStackToList :: ExecStack -> [Frame]
execStackToList (ExecStack frames) = frames

-- | Rename multiple things at once with [(olds, news)] on a `Renameable`.
renamings :: Renamable a => [(Name, Name)] -> a -> a
renamings names a = foldr (\(old, new) -> renaming old new) a names

-- | Replaces all of the names old in the ExecState with a name seeded by new_seed
renameExecState :: Name -> Name -> ExecState -> ExecState
renameExecState old new_seed s =
    let
        (new, ng') = freshSeededName new_seed (exec_names s)
    in
    ExecState { exec_stack = renaming old new (exec_stack s)
              , exec_eenv = renaming old new (exec_eenv s)
              , exec_code = renaming old new (exec_code s)
              , exec_names = ng'
              , exec_paths = renaming old new (exec_paths s) }

-- | TypeClass definitions
instance Renamable ExecStack where
    renaming old new (ExecStack s) = ExecStack $ renaming old new s

instance Renamable Frame where
    renaming old new (CaseFrame i a) = CaseFrame (renaming old new i) (renaming old new a)
    renaming old new (ApplyFrame e) = ApplyFrame (renaming old new e)
    renaming old new (UpdateFrame n) = UpdateFrame (renaming old new n)