module G2.Internals.Language.CreateFuncs where

import G2.Internals.Language.Expr
import qualified G2.Internals.Language.ExprEnv as E
import G2.Internals.Language.Naming
import G2.Internals.Language.Syntax
import G2.Internals.Language.Support

import qualified Data.Map as M
import Data.Maybe

-- | createFuncs
-- Give a list of b's, and functions to generate names and expressions from those
-- b's, generates functions and puts them in the ExprEnv
-- The function to generate the expression gets the full list of b/Name pairs
-- All b/Name pairs are also stored in some s, using the provided function
createFuncs :: ExprEnv
            -> NameGen
            -> [b]
            -> s
            -> (b -> Name)
            -> (b -> Name -> s -> s)
            -> (s -> b -> NameGen -> (Expr, NameGen))
            -> (ExprEnv, NameGen, s)
createFuncs eenv ng genFrom store namef storef exprf =
    let
        --Generate names, put them in the store
        (names, ng2) = freshSeededNames (map namef genFrom) ng
        genFromNames = zip genFrom names

        fullStore = foldr (uncurry storef) store genFromNames

        --Generate functions, put them in the expression environment
        (exprfs, ng3) = mapNG (exprf fullStore) genFrom ng2
        eenv2 = foldr (uncurry E.insert) eenv (zip names exprfs)

    in
    (eenv2, ng3, fullStore)

-- | createAlgDataTyWalks
-- A special case of createFunc that simplifies creating functions for each
-- type in the TypeEnv.
-- The function names are generated by appending a string to the Type name
-- retf gives the return type of the generated functions
-- boundf maybe creates arguments for each bound name in the AlgDataTy
-- The altf function maybe returns an expression for pattern matching on a DC
-- The defaultf generates a Default expression
-- createAlgDataTyWalks :: ExprEnv
--                      -> TypeEnv
--                      -> NameGen
--                      -> String
--                      -> (AlgDataTy -> Type)
--                      -> (Name -> [(c, Type)])
--                      -> (Walkers -> DataCon -> Id -> [Id] -> [(Maybe c, Id)] -> Maybe Expr)
--                      -> (Id -> Expr)
--                      -> (ExprEnv, NameGen, Walkers)
-- createAlgDataTyWalks eenv tenv ng s retf boundf altf defaultf =
--     let
--         b = M.toList tenv
--     in
--     createFuncs eenv ng b M.empty (createAlgDataTyWalkName s . fst) (insertWalkers retf boundf) (createAlgDataTyExpr boundf altf defaultf)

-- createAlgDataTyWalkName :: String -> Name -> Name
-- createAlgDataTyWalkName s (Name n _ _) = Name (s ++ n) Nothing 0

-- insertWalkers :: (AlgDataTy -> Type) -> (Name -> [(c, Type)]) -> (Name, AlgDataTy) -> Name -> Walkers -> Walkers
-- insertWalkers retf boundf (n, adt) n' w =
--     let
--         bn = bound_names adt

--         bnTy = map snd $ concatMap boundf bn
--         adtTy = TyConApp n $ map (TyVar . flip Id TYPE) bn 
--         ret = retf adt

--         ty = foldr TyFun ret (adtTy:bnTy)
--     in
--     M.insert n (Id n' ty) w

-- createAlgDataTyExpr :: (Name -> [(c, Type)])
--                     -> (Walkers -> DataCon -> Id -> [Id] -> [(Maybe c, Id)] -> Maybe Expr)
--                     -> (Id -> Expr)
--                     -> Walkers
--                     -> (Name, AlgDataTy)
--                     -> NameGen
--                     -> (Expr, NameGen)
-- createAlgDataTyExpr boundf altf defaultf w (n, adt) ng =
--     let
--         bn = bound_names adt

--         ct = concatMap (map (mapFst Just) . boundf) bn
--         adtTy = TyConApp n $ map (TyVar . flip Id TYPE) bn
--     in
--     mkMappedLamBindings ng (ct ++ [(Nothing, adtTy)]) (createAlgDataTyExpr' altf defaultf w )

-- createAlgDataTyExpr' :: (Walkers -> DataCon -> Id -> [Id] -> [(Maybe c, Id)] -> Maybe Expr)
--                      -> (Id -> Expr)
--                      -> Walkers
--                      -> [(Maybe c, Id)]
--                      -> Expr
-- createAlgDataTyExpr' altf defaultf w ns i =


-- createAlgDataTyAlts :: (Walkers -> DataCon -> Id -> [Id] -> Maybe Expr) -> Walkers -> [(Name, AlgDataTy)] -> Maybe Expr
-- createAlgDataTyAlts = undefined

-- createAlgDataTyDefault :: (Id -> Expr) -> Walkers -> [(Name, AlgDataTy)] -> Expr
-- createAlgDataTyDefault = undefined

-- mapFst :: (a -> c) -> (a, b) -> (c, b)
-- mapFst f (x, y) = (f x, y)

-- module G2.Internals.Language.CreateFuncs ( createFuncs
--                                          , createFunc
--                                          , createAlgDataTyWalks
--                                          , NameGenFunc
--                                          , ExprGenFunc
--                                          , StoreGenFunc) where

-- import G2.Internals.Language.Naming
-- import G2.Internals.Language.Syntax
-- import G2.Internals.Language.Support
-- import qualified G2.Internals.Language.ExprEnv as E

-- import qualified Data.Map as M
-- import Data.Maybe

-- type NameGenFunc a = a -> Name
-- type ExprGenFunc a b = NameGen -> [(a, Name, b)] -> a -> b -> (Expr, NameGen)
-- type StoreGenFunc a b c = c -> a -> b -> Name -> Expr -> c

-- -- | createFuncs
-- -- Given some [(a, b)], and functions to convert a's to Names and b's to Exprs, creates
-- -- new functions with the given Names and Exprs
-- -- The function returned by the name function will always be fed through a NameGen,
-- -- so it will not conflict with anything in the environment
-- -- The [(Name, b)] given to the Expr generating function is the created mapping from Names to b's
-- -- We also take a c, and a function to allow storing some information about the generated functions
-- -- in that c.
-- createFuncs :: ExprEnv -> NameGen
--             -> [(a, b)]
--             -> c 
--             -> NameGenFunc a
--             -> ExprGenFunc a b
--             -> StoreGenFunc a b c
--             -> (ExprEnv, NameGen, c)
-- createFuncs eenv ng xs store fn fe fs =
--     let
--         (ns, ng') = freshSeededNames (map (fn . fst) xs) ng

--         xsFst = map fst xs
--         xsSnd = map snd xs

--         (eenv', ng'', store') =
--             createFuncs' eenv ng' (zip3 xsFst ns xsSnd) (zip3 xsFst ns xsSnd) store fe fs
--     in
--     (eenv', ng'', store')

-- createFuncs' :: ExprEnv -> NameGen 
--              -> [(a, Name, b)]
--              -> [(a, Name, b)]
--              -> c
--              -> ExprGenFunc a b
--              -> StoreGenFunc a b c
--              -> (ExprEnv, NameGen, c)
-- createFuncs' eenv ng _ [] store _ _ = (eenv, ng, store)
-- createFuncs' eenv ng ne ((x, n, y):xs) store fe fs =
--     let
--         (eenv', ng', store') = createFunc eenv ng ne n x y store fe fs
--     in
--     createFuncs' eenv' ng' ne xs store' fe fs

-- createFunc :: ExprEnv -> NameGen
--            -> [(a, Name, b)]
--            -> Name
--            -> a -> b -> c
--            -> ExprGenFunc a b
--            -> StoreGenFunc a b c
--            -> (ExprEnv, NameGen, c)
-- createFunc eenv ng ne n x y store fe fs =
--     let
--         (e, ng') = fe ng ne x y
--         eenv' = E.insert n e eenv

--         store' = fs store x y n e
--     in
--     (eenv', ng', store')

-- -- Types for createAlgDataTyWalks
-- type AltFunc a = DataCon -- The DataCon being pattern match on
--                -> AlgDataTy
--                -> [(Name, Name, AlgDataTy)]
--                -> NameGen
--                -> Id -- The Case binder
--                -> [Id] -- Binders for each DataCon argument
--                -> [(a, Id)] -- The non datacon arguments
--                -> (Maybe Expr, NameGen)

-- type DefaultFunc a = AlgDataTy -> [(Name, Name, AlgDataTy)] -> NameGen -> Id -> [(a, Id)] -> (Expr, NameGen)

-- -- | createAlgDataTyWalks
-- -- A special case of createFunc where the function names are generated by
-- -- appending to each ADT type name, the expressions are generated from the type
-- -- names and the cooresponding AlgDataTy's, and the results are stored
-- -- in a Walkers Map
-- createAlgDataTyWalks :: ExprEnv -> TypeEnv -> NameGen
--                      -> (AlgDataTy -> [(a, Maybe Name, Type)]) -- Other arguments that should be created
--                      -> String -- A string to append to a DC Name, to create a new function name
--                      -> AltFunc a -- Maybe creates an Alt for each DC
--                      -> DefaultFunc a -- Creates an Expr for a Default DC
--                      -> StoreGenFunc Name AlgDataTy Walkers
--                      -> (ExprEnv, NameGen, Walkers)
-- createAlgDataTyWalks eenv tenv ng falg s fe fd fs  =
--     let
--         tenv_list = M.toList tenv

--         (eenv', ng', w) = createFuncs eenv ng tenv_list M.empty
--                             (createAlgDataTyWalkName s) 
--                             (createAlgDataTyWalkExpr falg fe fd)
--                             fs
--     in
--     (eenv', ng', w)

-- createAlgDataTyWalkName :: String -> Name -> Name
-- createAlgDataTyWalkName s (Name n _ _) = Name (s ++ n) Nothing 0


-- createAlgDataTyWalkExpr :: (AlgDataTy -> [(a, Maybe Name, Type)])
--                         -> AltFunc a
--                         -> DefaultFunc a
--                         -> NameGen -> [(Name, Name, AlgDataTy)] -> Name
--                         -> AlgDataTy
--                         -> (Expr, NameGen)
-- createAlgDataTyWalkExpr falg fa fd ng nm tn adt =
--     let
--         arg_ty = falg adt
--     in
--     mkLamBindings ng arg_ty $ \ng' is -> createAlgDataTyWalkExpr' fa fd ng' nm tn adt is

-- createAlgDataTyWalkExpr' :: AltFunc a
--                         -> DefaultFunc a
--                         -> NameGen -> [(Name, Name, AlgDataTy)] -> Name
--                         -> AlgDataTy
--                         -> [(a, Id)]
--                         -> (Expr, NameGen)
-- createAlgDataTyWalkExpr' fa fd ng nm tn adt is =
--     let        
--         (l_bind_id, ng2) = freshId (TyConApp tn []) ng
--         l_var = Var l_bind_id

--         (c_bind_id, ng3) = freshId (TyConApp tn []) ng2

--         (defExpr, ng4) = fd adt nm ng3 c_bind_id is
--         def = Alt Default defExpr

--         (alts, ng5) = createAlgDataTyWalkAlt fa (dataCon adt) adt nm ng4 c_bind_id is

--         (c, ng6) =  
--                 case isDataTyCon adt of
--                     True -> (Case l_var c_bind_id (def:alts), ng5)
--                     False -> 
--                         let
--                             dc@(DataCon _ _ ts) = (dataCon adt) !! 0
--                             (arg_ids, ng') = freshIds ts ng

--                             (e', ng'') = fa dc adt nm ng' c_bind_id arg_ids is
--                         in
--                         (fromJust $  e', ng'')

--         e = Lam l_bind_id c

--     in
--     (e, ng6)

-- createAlgDataTyWalkAlt ::
--     AltFunc a
--     -> [DataCon]
--     -> AlgDataTy
--     -> [(Name, Name, AlgDataTy)]
--     -> NameGen
--     -> Id
--     -> [(a, Id)]
--     -> ([Alt], NameGen)
-- createAlgDataTyWalkAlt _ [] _ _ ng _ _  = ([], ng)
-- createAlgDataTyWalkAlt f (dc@(DataCon _ _ ts):dcs) adt nm ng i is =
--     let
--         (arg_ids, ng2) = freshIds ts ng

--         (e, ng3) = f dc adt nm ng2 i arg_ids is
--         (as, ng4) = createAlgDataTyWalkAlt f dcs adt nm ng3 i is

--         am = DataAlt dc arg_ids
--     in
--     case e of
--         Just e' -> (Alt am e':as, ng4)
--         Nothing -> (as, ng4)
-- createAlgDataTyWalkAlt _ (PrimCon _:_) _ _ _ _ _ = error "PrimCon in createAlgDataTyWalkAlt"