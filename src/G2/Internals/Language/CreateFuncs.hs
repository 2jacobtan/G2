module G2.Internals.Language.CreateFuncs ( createFuncs
                                         , createFunc
                                         , createAlgDataTyWalks
                                         , NameGenFunc
                                         , ExprGenFunc
                                         , StoreGenFunc) where

import G2.Internals.Language.Expr
import G2.Internals.Language.Naming
import G2.Internals.Language.Syntax
import G2.Internals.Language.Support
import qualified G2.Internals.Language.ExprEnv as E

import qualified Data.Map as M

type NameGenFunc a = a -> Name
type ExprGenFunc a b = NameGen -> [(a, Name, b)] -> a -> b -> (Expr, NameGen)
type StoreGenFunc a b c = c -> a -> b -> Name -> Expr -> c

-- | createFuncs
-- Given some [(a, b)], and functions to convert a's to Names and b's to Exprs, creates
-- new functions with the given Names and Exprs
-- The function returned by the name function will always be fed through a NameGen,
-- so it will not conflict with anything in the environment
-- The [(Name, b)] given to the Expr generating function is the created mapping from Names to b's
-- We also take a c, and a function to allow storing some information about the generated functions
-- in that c.
createFuncs :: ExprEnv -> NameGen
            -> [(a, b)]
            -> c 
            -> NameGenFunc a
            -> ExprGenFunc a b
            -> StoreGenFunc a b c
            -> (ExprEnv, NameGen, c)
createFuncs eenv ng xs store fn fe fs =
    let
        (ns, ng') = freshSeededNames (map (fn . fst) xs) ng

        xsFst = map fst xs
        xsSnd = map snd xs

        (eenv', ng'', store') =
            createFuncs' eenv ng' (zip3 xsFst ns xsSnd) (zip3 xsFst ns xsSnd) store fe fs
    in
    (eenv', ng'', store')

createFuncs' :: ExprEnv -> NameGen 
             -> [(a, Name, b)]
             -> [(a, Name, b)]
             -> c
             -> ExprGenFunc a b
             -> StoreGenFunc a b c
             -> (ExprEnv, NameGen, c)
createFuncs' eenv ng _ [] store _ _ = (eenv, ng, store)
createFuncs' eenv ng ne ((x, n, y):xs) store fe fs =
    let
        (eenv', ng', store') = createFunc eenv ng ne n x y store fe fs
    in
    createFuncs' eenv' ng' ne xs store' fe fs

createFunc :: ExprEnv -> NameGen
           -> [(a, Name, b)]
           -> Name
           -> a -> b -> c
           -> ExprGenFunc a b
           -> StoreGenFunc a b c
           -> (ExprEnv, NameGen, c)
createFunc eenv ng ne n x y store fe fs =
    let
        (e, ng') = fe ng ne x y
        eenv' = E.insert n e eenv

        store' = fs store x y n e
    in
    (eenv', ng', store')

-- Types for createAlgDataTyWalks
type AltFunc a = DataCon -- The DataCon being pattern match on
               -> [(Name, Name, AlgDataTy)]
               -> NameGen
               -> Id -- The Case binder
               -> [Id] -- Binders for each DataCon argument
               -> [(a, Id)] -- The non datacon arguments
               -> (Maybe Expr, NameGen)

type DefaultFunc a = [(Name, Name, AlgDataTy)] -> NameGen -> Id -> [(a, Id)] -> (Expr, NameGen)

-- | createAlgDataTyWalks
-- A special case of createFunc where the function names are generated by
-- appending to each ADT type name, the expressions are generated from the type
-- names and the cooresponding AlgDataTy's, and the results are stored
-- in a Walkers Map
createAlgDataTyWalks :: ExprEnv -> TypeEnv -> NameGen
                     -> (AlgDataTy -> [(a, Maybe Name, Type)]) -- Other arguments that should be created
                     -> String -- A string to append to a DC Name, to create a new function name
                     -> AltFunc a -- Maybe creates an Alt for each DC
                     -> DefaultFunc a -- Creates an Expr for a Default DC
                     -> StoreGenFunc Name AlgDataTy Walkers
                     -> (ExprEnv, NameGen, Walkers)
createAlgDataTyWalks eenv tenv ng falg s fe fd fs  =
    let
        tenv_list = M.toList tenv

        (eenv', ng', w) = createFuncs eenv ng tenv_list M.empty
                            (createAlgDataTyWalkName s) 
                            (createAlgDataTyWalkExpr falg fe fd)
                            fs
    in
    (eenv', ng', w)

createAlgDataTyWalkName :: String -> Name -> Name
createAlgDataTyWalkName s (Name n _ _) = Name (s ++ n) Nothing 0


createAlgDataTyWalkExpr :: (AlgDataTy -> [(a, Maybe Name, Type)])
                        -> AltFunc a
                        -> DefaultFunc a
                        -> NameGen -> [(Name, Name, AlgDataTy)] -> Name
                        -> AlgDataTy
                        -> (Expr, NameGen)
createAlgDataTyWalkExpr falg fa fd ng nm tn adt@(DataTyCon _ _) =
    let
        arg_ty = falg adt
    in
    mkLamBindings ng arg_ty $ \ng' is -> createAlgDataTyWalkExpr' fa fd ng' nm tn adt is

createAlgDataTyWalkExpr' :: AltFunc a
                        -> DefaultFunc a
                        -> NameGen -> [(Name, Name, AlgDataTy)] -> Name
                        -> AlgDataTy
                        -> [(a, Id)]
                        -> (Expr, NameGen)
createAlgDataTyWalkExpr' fa fd ng nm tn (DataTyCon _ dc) is =
    let        
        (l_bind_id, ng2) = freshId (TyConApp tn []) ng
        l_var = Var l_bind_id

        (c_bind_id, ng3) = freshId (TyConApp tn []) ng2

        (defExpr, ng4) = fd nm ng3 c_bind_id is
        def = Alt Default defExpr

        (alts, ng5) = createAlgDataTyWalkAlt fa dc nm ng4 c_bind_id is

        c = Lam l_bind_id $ Case l_var c_bind_id (def:alts)
    in
    (c, ng5)

createAlgDataTyWalkAlt ::
    AltFunc a
    -> [DataCon]
    -> [(Name, Name, AlgDataTy)]
    -> NameGen
    -> Id
    -> [(a, Id)]
    -> ([Alt], NameGen)
createAlgDataTyWalkAlt _ [] _ ng _ _  = ([], ng)
createAlgDataTyWalkAlt f (dc@(DataCon _ _ ts):dcs) nm ng i is =
    let
        (arg_ids, ng2) = freshIds ts ng

        (e, ng3) = f dc nm ng2 i arg_ids is
        (as, ng4) = createAlgDataTyWalkAlt f dcs nm ng3 i is

        am = DataAlt dc arg_ids
    in
    case e of
        Just e' -> (Alt am e':as, ng4)
        Nothing -> (as, ng4)
createAlgDataTyWalkAlt _ (PrimCon _:_) _ _ _ _ = error "PrimCon in createAlgDataTyWalkAlt"
