module G2.Liquid.Inference.Interface (inference) where

import G2.Config.Config as G2
import G2.Execution.Memory
import G2.Interface hiding (violated)
import G2.Language.CallGraph
import qualified G2.Language.ExprEnv as E
import G2.Language.Naming
import G2.Language.Support
import G2.Language.Syntax
import G2.Liquid.AddTyVars
import G2.Liquid.Inference.Config
import G2.Liquid.Inference.FuncConstraint as FC
import G2.Liquid.Inference.G2Calls
import G2.Liquid.Inference.PolyRef
import G2.Liquid.Helpers
import G2.Liquid.Inference.RefSynth
import G2.Liquid.Inference.GeneratedSpecs
import G2.Liquid.Inference.Verify
import G2.Liquid.Interface
import G2.Liquid.Types
import G2.Translation

import Language.Haskell.Liquid.Types as LH
import Language.Fixpoint.Types hiding (Safe, Unsafe, Crash)

import Control.Monad
import Data.Either
import qualified Data.HashSet as S
import Data.List
import Data.Maybe
import Data.Monoid
import qualified Data.Text as T

import Language.Haskell.Liquid.Types
import Language.Haskell.Liquid.Types.RefType
import qualified Language.Fixpoint.Types.Config as FP

import Var (Var, varName, varType)

import Debug.Trace

type WorkingUp = S.HashSet T.Text

data Direction = Up | Down deriving (Eq, Show, Read)

inference :: InferenceConfig -> G2.Config -> [FilePath] -> [FilePath] -> [FilePath] -> IO (Either [CounterExample] GeneratedSpecs)
inference infconfig config proj fp lhlibs = do
    -- Initialize LiquidHaskell
    lhconfig <- lhConfig proj lhlibs
    let lhconfig' = lhconfig { pruneUnsorted = True
                             -- Block qualifiers being auto-generated by LH (for fair comparison)
                             , maxParams = 0
                             , eliminate = if keep_quals infconfig then eliminate lhconfig else FP.All
                             , higherorderqs = False
                             , scrapeImports = False
                             , scrapeInternals = False
                             , scrapeUsedImports = False }
    ghci <- ghcInfos Nothing lhconfig' fp

    mapM (print . gsQualifiers . spec) ghci

    -- Initialize G2
    let g2config = config { mode = Liquid
                          , steps = 2000 }
        transConfig = simplTranslationConfig { simpl = False }
    exg2@(main_mod, _) <- translateLoaded proj fp lhlibs transConfig g2config

    let simp_s = initSimpleState (snd exg2)
        (g2config', infconfig') = adjustConfig main_mod simp_s g2config infconfig ghci

        lrs = createStateForInference simp_s g2config' ghci

        cg = getCallGraph . expr_env . state . lr_state $ lrs

    inf <- inference' infconfig' g2config' lhconfig' ghci (fst exg2) lrs cg S.empty Down emptyGS emptyFC
    case inf of
        CEx cex -> return $ Left cex
        GS gs -> return $ Right gs
        FCs _ -> error "inference: Unhandled Func Constraints"

data InferenceRes = CEx [CounterExample]
                  | FCs FuncConstraints
                  | GS GeneratedSpecs
                  deriving (Show)

inference' :: InferenceConfig -> G2.Config -> LH.Config -> [GhcInfo] -> Maybe T.Text -> LiquidReadyState
           -> CallGraph -> WorkingUp -> Direction -> GeneratedSpecs -> FuncConstraints -> IO InferenceRes
inference' infconfig g2config lhconfig ghci m_modname lrs cg wu dir gs fc = do
    putStrLn "Inference Down"
    print gs

    res <- tryHardToVerify infconfig lhconfig ghci gs

    case res of
        Right new_gs
            | nullAssumeGS gs -> return $ GS new_gs
            | otherwise ->
                let gs' = switchAssumesToAsserts gs
                    ghci' = addSpecsToGhcInfos ghci gs'
                in
                inference' infconfig g2config lhconfig ghci' m_modname lrs cg wu dir gs' fc
        Left bad -> do
            ref <- refineUnsafe infconfig g2config lhconfig ghci m_modname lrs cg wu dir gs fc bad
            case ref of
                FCs new_fc -> conflictingFCs infconfig g2config lhconfig ghci m_modname lrs cg wu dir gs fc new_fc
                _ -> return ref

refineUnsafe :: InferenceConfig -> G2.Config -> LH.Config -> [GhcInfo] -> Maybe T.Text -> LiquidReadyState
             -> CallGraph -> WorkingUp -> Direction -> GeneratedSpecs -> FuncConstraints -> [Name] -> IO InferenceRes
refineUnsafe infconfig g2config lhconfig ghci m_modname lrs cg wu dir gs fc bad = do
    let merged_se_ghci = addSpecsToGhcInfos ghci (switchAssumesToAsserts gs)

    let bad' = nub $ map nameOcc bad

    res <- mapM (genNewConstraints merged_se_ghci m_modname lrs infconfig g2config) bad'

    putStrLn $ "res"
    printCE $ concat res
    let res' = concat res

    -- Either converts counterexamples to FuncConstraints, or returns them as errors to
    -- show to the user.
    new_fc <- checkNewConstraints ghci lrs infconfig g2config wu dir res'

    case new_fc of
        Left cex -> return $ CEx cex
        Right new_fc' -> do
            -- Only consider functions in the modules that we have access to.
            let new_fc_m = relFuncs infconfig new_fc'

            -- Check if we already have specs for any of the functions
            let pre_solved = alreadySpecified ghci new_fc'

            case nullFC pre_solved of
                False -> return $ FCs pre_solved
                True -> do
                    let fc' = unionFC fc new_fc'

                    putStrLn "Before genMeasureExs"
                    meas_ex <- genMeasureExs lrs merged_se_ghci g2config fc'
                    putStrLn "After genMeasureExs"
                    gs' <- foldM (synthesize infconfig ghci lrs meas_ex fc') gs new_fc_m

                    let new_dir = any (\r -> checkWalkBack infconfig r == Up) res'
                        comb_dir = if new_dir == True then Up else Down
                    
                    inference' infconfig g2config lhconfig ghci m_modname lrs cg wu comb_dir gs' fc'

conflictingFCs :: InferenceConfig -> G2.Config -> LH.Config -> [GhcInfo] -> Maybe T.Text -> LiquidReadyState
               -> CallGraph -> WorkingUp -> Direction -> GeneratedSpecs -> FuncConstraints -> FuncConstraints -> IO InferenceRes
conflictingFCs infconfig g2config lhconfig ghci m_modname lrs cg wu dir gs fc new_fc =
    let f_new_fc = alreadySpecified ghci new_fc in 
    case nullFC f_new_fc of
        False -> return $ FCs new_fc
        True ->
            let
                merged_fc = unionFC fc new_fc

                constrained = map (funcName . constraint) $ toListFC new_fc
                merged_fc' = mapFC (\c -> if generated_by c `intersect` constrained /= []
                                                        then c { bool_rel = BRImplies }
                                                        else c ) merged_fc
            in
            inference' infconfig g2config lhconfig ghci m_modname lrs cg wu dir gs merged_fc'

-- inference' :: InferenceConfig -> G2.Config -> LH.Config -> [GhcInfo] -> Maybe T.Text -> LiquidReadyState
--            -> CallGraph -> WorkingUp -> GeneratedSpecs -> FuncConstraints -> IO (Either [CounterExample] GeneratedSpecs)
-- inference' infconfig g2config lhconfig ghci m_modname lrs cg wu gs fc = do
--     print gs

--     let merged_verify_with_quals_ghci = addQualifiersToGhcInfos gs $ addSpecsToGhcInfos ghci gs

--     res_quals <- verify infconfig lhconfig merged_verify_with_quals_ghci

--     case res_quals of
--         Safe 
--             | nullAssumeGS gs -> return $ Right gs
--             | otherwise -> inference' infconfig g2config lhconfig ghci m_modname lrs cg wu (switchAssumesToAsserts gs) fc
--         Crash ci err -> error $ "Crash\n" ++ show ci ++ "\n" ++ err
--         Unsafe x -> do putStrLn ("x = " ++ show x); refineUnsafe infconfig g2config lhconfig ghci m_modname lrs cg wu gs fc

-- refineUnsafe :: InferenceConfig -> G2.Config -> LH.Config -> [GhcInfo] -> Maybe T.Text -> LiquidReadyState
--              -> CallGraph -> WorkingUp -> GeneratedSpecs -> FuncConstraints -> IO (Either [CounterExample] GeneratedSpecs)
-- refineUnsafe infconfig g2config lhconfig ghci m_modname lrs cg wu gs fc = do
--     let merged_verify_with_asserts_ghci = addQualifiersToGhcInfos gs $ addSpecsToGhcInfos ghci gs
--         merged_se_ghci = addSpecsToGhcInfos ghci (switchAssumesToAsserts gs)

--     res_asserts <- verify infconfig lhconfig merged_verify_with_asserts_ghci
    
--     case res_asserts of
--         Unsafe bad -> do
--             let bad' = nub $ map nameOcc bad

--             putStrLn $ "bad' = " ++ show bad'

--             -- Generate new constraints for the functions that LH reports as having an error
--             res <- mapM (genNewConstraints merged_se_ghci m_modname lrs infconfig g2config) bad'

--             putStrLn $ "res"
--             printCE $ concat res

--             putStrLn "Before checkNewConstraints"

--             let res' = concat res
--             -- Either converts counterexamples to FuncConstraints, or returns them as errors to
--             -- show to the user.
--             new_fc <- checkNewConstraints ghci lrs infconfig g2config wu res'
--             let wu' = foldr (adjustWorkingUp infconfig) wu res'

--             case new_fc of
--                 Left ce -> return . Left $ ce
--                 Right new_fc' -> do
--                     -- Only consider functions in the modules that we have access to.
--                     let new_fc_funcs = filter (\(Name _ m _ _) -> m `S.member` (modules infconfig))
--                                      . nubBy (\n1 n2 -> nameOcc n1 == nameOcc n2) . map (funcName . constraint) $ allFC new_fc'
--                     let fc' = unionFC fc new_fc'

--                     case madeWrongGuesses res' of
--                         [] -> do

--                             -- Only check new assertions
--                             let gs' = filterAssertsKey (\n -> n `elem` map constraining (allFC fc')) gs

--                             -- Synthesize
--                             putStrLn "Before genMeasureExs"
--                             meas_ex <- genMeasureExs lrs merged_se_ghci g2config fc'
--                             putStrLn "After genMeasureExs"
--                             gs'' <- foldM (synthesize infconfig ghci lrs meas_ex fc') gs' new_fc_funcs
                            
--                             inference' infconfig g2config lhconfig ghci m_modname lrs cg wu' gs'' fc'
--                         wrong -> do
--                             let fc'' = correctWrongGuessesInFC wrong fc'
--                                 gs' = correctWrongGuessesInGS wrong cg gs

--                             meas_ex <- genMeasureExs lrs merged_se_ghci g2config fc'
--                             putStrLn "After genMeasureExs"
--                             gs'' <- foldM (synthesize infconfig ghci lrs meas_ex fc') gs' new_fc_funcs

--                             inference' infconfig g2config lhconfig ghci m_modname lrs cg wu' gs'' fc''

--         _ -> error $ "refineUnsafe: result other than Unsafe: "
--                         ++ case res_asserts of {Safe -> "Safe"; Crash _ _-> "Crash"; Unsafe _ -> "Unsafe"}

createStateForInference :: SimpleState -> G2.Config -> [GhcInfo] -> LiquidReadyState
createStateForInference simp_s config ghci =
    let
        (simp_s', ph_tyvars) = if add_tyvars config
                                then fmap Just $ addTyVarsEEnvTEnv simp_s
                                else (simp_s, Nothing)
        (s, b) = initStateFromSimpleState simp_s' True 
                    (\_ ng _ _ _ _ -> (Prim Undefined TyBottom, [], [], ng))
                    (\_ -> [])
                    config
    in
    createLiquidReadyState s b ghci ph_tyvars config


genNewConstraints :: [GhcInfo] -> Maybe T.Text -> LiquidReadyState -> InferenceConfig -> G2.Config -> T.Text -> IO [CounterExample]
genNewConstraints ghci m lrs infconfig g2config n = do
    putStrLn $ "Generating constraints for " ++ T.unpack n
    ((exec_res, _), i) <- runLHInferenceCore n m lrs ghci infconfig g2config
    return $ map (lhStateToCE i) exec_res

checkNewConstraints :: [GhcInfo] -> LiquidReadyState -> InferenceConfig ->  G2.Config -> WorkingUp -> Direction -> [CounterExample] -> IO (Either [CounterExample] FuncConstraints)
checkNewConstraints ghci lrs infconfig g2config wu dir cexs = do
    let res = map (cexsToFuncConstraints lrs ghci infconfig g2config wu dir) cexs
    case lefts res of
        res'@(_:_) -> return . Left $ res'
        _ -> return . Right . filterErrors . unionsFC . rights $ res

alreadySpecified :: [GhcInfo] -> FuncConstraints -> FuncConstraints
alreadySpecified ghci = filterFC (flip isPreRefined ghci . funcName . constraint)

genMeasureExs :: LiquidReadyState -> [GhcInfo] -> G2.Config -> FuncConstraints -> IO MeasureExs
genMeasureExs lrs ghci g2config fcs =
    let
        es = concatMap (\fc ->
                    let
                        cons = constraint fc
                        ex_poly = concat . concatMap extractValues . concatMap extractExprPolyBound $ returns cons:arguments cons
                    in
                    returns cons:arguments cons ++ ex_poly
                ) (toListFC fcs)
    in
    evalMeasures lrs ghci g2config es

synthesize :: InferenceConfig -> [GhcInfo] -> LiquidReadyState -> MeasureExs -> FuncConstraints -> GeneratedSpecs -> Name -> IO GeneratedSpecs
synthesize infconfig ghci lrs meas_ex fc gs n = do
    spec_qual <- refSynth infconfig ghci lrs meas_ex fc n

    case spec_qual of
        Just (new_spec, new_qual) -> do
            putStrLn $ "new_qual = " ++ show new_qual

            -- We ASSUME postconditions, and ASSERT preconditions.  This ensures
            -- that our precondition is satisified by the caller, and the postcondition
            -- is strong enough to allow verifying the caller
            let gs' = insertNewSpec n new_spec gs

            return $ foldr insertQualifier gs' new_qual
        Nothing -> return gs

-- synthesizePre :: InferenceConfig -> [GhcInfo] -> LiquidReadyState -> MeasureExs -> FuncConstraints -> GeneratedSpecs -> Name -> IO GeneratedSpecs
-- synthesizePre infconfig ghci lrs meas_ex fc gs n = do
--     spec_qual <- refSynth infconfig ghci lrs meas_ex fc n

--     case spec_qual of
--         Just (new_spec, new_qual) -> do
--             putStrLn $ "new_qual = " ++ show new_qual

--             let gs' = insertAssertGS n (pre new_spec) gs

--             return $ foldr insertQualifier gs' new_qual
--         Nothing -> return gs
--     where
--         pre xs = init xs ++ [PolyBound PTrue []]

-- | Converts counterexamples into constraints that the refinements must allow for, or rule out.
cexsToFuncConstraints :: LiquidReadyState -> [GhcInfo] -> InferenceConfig -> G2.Config -> WorkingUp -> Direction -> CounterExample -> Either CounterExample FuncConstraints
cexsToFuncConstraints _ _ infconfig _ _ _ (DirectCounter dfc fcs@(_:_))
    | not . null $ fcs' =
        let
            mkFC pol fc = FC { polarity = if notRetError fc then pol else Neg
                             , violated = Post
                             , generated_by = [funcName dfc]
                             , bool_rel = if notRetError fc then BRAnd else BRImplies
                             , constraint = fc}
        in
        Right . insertsFC $ map (mkFC Pos . real) fcs' ++ map (mkFC Neg . abstract) fcs'
    | otherwise = Right $ error "cexsToFuncConstraints: unhandled 1"
    where
        fcs' = filter (\fc -> abstractedMod fc `S.member` modules infconfig) fcs
cexsToFuncConstraints _ _ infconfig _ _ _ (CallsCounter dfc cfc fcs@(_:_))
    | not . null $ fcs' =
        let
            mkFC pol fc = FC { polarity = if notRetError fc then pol else Neg
                             , violated = Post
                             , generated_by = [funcName dfc, funcName cfc]
                             , bool_rel = if notRetError fc then BRAnd else BRImplies
                             , constraint = fc}
        in
        Right . insertsFC $ map (mkFC Pos . real) fcs' ++ map (mkFC Neg . abstract) fcs'
    | otherwise = Right $ error "cexsToFuncConstraints: Should be unreachable! Non-refinable function abstracted!"
    where
        fcs' = filter (\fc -> abstractedMod fc `S.member` modules infconfig) fcs
cexsToFuncConstraints lrs ghci infconfig _ _ _ cex@(DirectCounter fc []) = do
    let Name n m _ _ = funcName fc
    case (n, m) `S.member` pre_refined infconfig of
        False ->
            Right . insertsFC $ [FC { polarity = if notRetError fc then Pos else Neg
                                    , violated = Post
                                    , generated_by = [funcName fc]
                                    , bool_rel = if notRetError fc then BRAnd else BRImplies
                                    , constraint = fc} ]
        True -> Left $ cex
cexsToFuncConstraints lrs ghci infconfig _ wu dir cex@(CallsCounter caller_fc called_fc []) = do
    let caller_pr = hasUserSpec (funcName caller_fc) infconfig
        called_pr = hasUserSpec (funcName called_fc) infconfig

    case (caller_pr, called_pr) of
        (True, True) -> Left $ cex
        (False, True) ->  Right . insertsFC $ [FC { polarity = Neg
                                                  , violated = Pre
                                                  , generated_by = [funcName called_fc]
                                                  , bool_rel = BRImplies 
                                                  , constraint = caller_fc } ]
        (True, False) -> Right . insertsFC $ [FC { polarity = if notRetError called_fc then Pos else Neg
                                                 , violated = Pre
                                                 , generated_by = [funcName caller_fc]
                                                 , bool_rel = if notRetError called_fc then BRAnd else BRImplies
                                                 , constraint = called_fc } ]
        (False, False)
            | dir == Up -> 
                           Right . insertsFC $ [FC { polarity = Neg
                                                   , violated = Pre
                                                   , generated_by = [funcName called_fc]
                                                   , bool_rel = BRImplies
                                                   , constraint = caller_fc } ]
            | otherwise -> Right . insertsFC $ [FC { polarity = if notRetError called_fc then Pos else Neg
                                                   , violated = Pre
                                                   , generated_by = [funcName caller_fc]
                                                   , bool_rel = if notRetError called_fc then BRAnd else BRImplies
                                                   , constraint = called_fc } ]

-- | Returns true if we should switch from walking down the call graph to walking up it
checkWalkBack :: InferenceConfig -> CounterExample -> Direction
checkWalkBack infconfig (CallsCounter caller_fc called_fc []) =
    let
        caller_pr = hasUserSpec (funcName caller_fc) infconfig
        called_pr = hasUserSpec (funcName called_fc) infconfig
    in
    if not caller_pr && called_pr then Up else Down
checkWalkBack _ _  = Down

isPreRefined :: Name -> [GhcInfo] -> Bool
isPreRefined (Name n m _ _) ghci =
    let
        pre_r = map (varToName . fst) . concatMap (gsTySigs . spec) $ ghci
    in
    any (\(Name n' m' _ _) -> n == n' && m == m' ) pre_r

hasUserSpec :: Name -> InferenceConfig -> Bool
hasUserSpec (Name n m _ _) infconfig = (n, m) `S.member` pre_refined infconfig

-- adjustWorkingUp :: InferenceConfig -> CounterExample -> WorkingUp -> WorkingUp
-- adjustWorkingUp infconfig (CallsCounter caller_fc called_fc []) wu =
--     let 
--         caller_pr = isPreRefined (funcName caller_fc) infconfig
--         called_pr = isPreRefined (funcName called_fc) infconfig
--     in
--     case (caller_pr, called_pr) of
--         (True, False) -> S.empty -- wu -- TODO
--         (False, False)
--             | nameOcc (funcName called_fc) `S.member` wu ->
--                     S.insert (nameOcc $ funcName called_fc) wu
--             | otherwise -> S.insert (nameOcc $ funcName called_fc) wu
--         _ -> wu 
-- adjustWorkingUp _ _ wu = wu

-- isPreRefined :: Name -> InferenceConfig -> Bool
-- isPreRefined (Name n m _ _) infconfig = (n, m) `S.member` pre_refined infconfig

getBoolRel :: FuncCall -> FuncCall -> BoolRel
getBoolRel fc1 fc2 =
    if notSameFunc fc1 fc2 && notRetError fc2 then BRAnd else BRImplies

notSameFunc :: FuncCall -> FuncCall -> Bool
notSameFunc fc1 fc2 = nameOcc (funcName fc1) /= nameOcc (funcName fc2)

notRetError :: FuncCall -> Bool
notRetError (FuncCall { returns = Prim Error _ }) = False
notRetError _ = True

insertsFC :: [FuncConstraint] -> FuncConstraints
insertsFC = foldr insertFC emptyFC

abstractedMod :: Abstracted -> Maybe T.Text
abstractedMod = nameModule . funcName . abstract

filterErrors :: FuncConstraints -> FuncConstraints
filterErrors = filterFC filterErrors'

filterErrors' :: FuncConstraint -> Bool
filterErrors' fc =
    let
        c = constraint fc

        as = not . any isError $ arguments c
        r = not . isError . returns $ c
    in
    as && (r || FC.violated fc == Pre)
    where
        isError (Prim Error _) = True
        isError _ = False


relFuncs :: InferenceConfig -> FuncConstraints -> [Name]
relFuncs infconfig = filter (\(Name _ m _ _) -> m `S.member` (modules infconfig))
                   . nubBy (\n1 n2 -> nameOcc n1 == nameOcc n2)
                   . map (funcName . constraint)
                   . toListFC

-- -- | Checks if we found an incorrect specification higher in the tree,
-- -- and if so indicates which function(s) were incorrectly guessed
-- madeWrongGuesses :: [CounterExample] -> [Name]
-- madeWrongGuesses = mapMaybe madeWrongGuess

-- madeWrongGuess :: CounterExample -> Maybe Name
-- madeWrongGuess (DirectCounter f []) = Just $ funcName f
-- madeWrongGuess (CallsCounter caller_f _ []) = Just $ funcName caller_f
-- madeWrongGuess _ = Nothing

-- -- Go back and try to reverify all functions that call the passed function
-- correctWrongGuessesInFC :: [Name] -> FuncConstraints -> FuncConstraints
-- correctWrongGuessesInFC ns =
--     mapFC (\fc -> if funcName (constraint fc) `elem` ns
--                     then fc { bool_rel = BRImplies}
--                     else fc)


-- correctWrongGuessesInGS :: [Name] -> CallGraph -> GeneratedSpecs -> GeneratedSpecs
-- correctWrongGuessesInGS ns cg gs =
--     foldr (\n -> correctWrongGuessInGS n cg) gs $ nub ns

-- correctWrongGuessInGS :: Name -> CallGraph -> GeneratedSpecs -> GeneratedSpecs
-- correctWrongGuessInGS n g gs =
--     trace ("wrong guess = " ++ show n)
--     deleteAssert n . deleteAssume n
--         $ foldr (\n -> moveAssertToSpec) gs $ calledBy n g
--     where
--         moveAssertToSpec
--             | Just s <- lookupAssertGS n gs = insertNewSpec n s
--             | otherwise = id


-------

getGoodCalls :: InferenceConfig -> G2.Config -> LH.Config -> [GhcInfo] -> Maybe T.Text -> LiquidReadyState -> IO [FuncCall]
getGoodCalls infconfig config lhconfig ghci m_mod lrs = do
    let es = map (\(Name n m _ _) -> (n, m)) . E.keys . expr_env . state $ lr_state lrs
        
        cs = map (mkName . varName) $ concatMap (map fst . gsTySigs . spec) ghci
        cs' = filter (\(Name n m _ _) -> (n, m) `elem` es && m == m_mod) cs

        cs'' = map nameOcc cs'

    putStrLn $ "cs'' = " ++ show cs''
    return . concat
        =<< mapM (\c -> gatherAllowedCalls c m_mod lrs ghci infconfig config) cs''

