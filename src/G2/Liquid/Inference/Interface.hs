module G2.Liquid.Inference.Interface ( inferenceCheck
                                     , inference) where

import G2.Config.Config as G2
import G2.Execution.Memory
import G2.Interface hiding (violated)
import G2.Language.CallGraph
import qualified G2.Language.ExprEnv as E
import G2.Language.Naming
import G2.Language.Support
import G2.Language.Syntax
import G2.Liquid.AddTyVars
import G2.Liquid.Inference.Config
import G2.Liquid.Inference.FuncConstraint as FC
import G2.Liquid.Inference.G2Calls
import G2.Liquid.Inference.PolyRef
import G2.Liquid.Helpers
import G2.Liquid.Inference.Sygus
import G2.Liquid.Inference.GeneratedSpecs
import G2.Liquid.Inference.Verify
import G2.Liquid.Inference.WorkingUp
import G2.Liquid.Interface
import G2.Liquid.Types
import G2.Translation

import Language.Haskell.Liquid.Types as LH
import Language.Fixpoint.Types hiding (Safe, Unsafe, Crash)

import Control.Monad
import Control.Monad.IO.Class 
import Data.Either
import qualified Data.HashSet as S
import Data.List
import Data.Maybe
import Data.Monoid
import qualified Data.Text as T

import Language.Haskell.Liquid.Types
import Language.Haskell.Liquid.Types.RefType
import qualified Language.Fixpoint.Types.Config as FP

import Var (Var, varName, varType)

import Debug.Trace

-- Run inference, with an extra, final check of correctness at the end.
-- Assuming inference is working correctly, this check should neve fail.
inferenceCheck :: InferenceConfig -> G2.Config -> [FilePath] -> [FilePath] -> [FilePath] -> IO (Either [CounterExample] GeneratedSpecs)
inferenceCheck infconfig config proj fp lhlibs = do
    (ghci, lhconfig) <- getGHCI infconfig config proj fp lhlibs
    res <- inference' infconfig config lhconfig ghci proj fp lhlibs
    case res of
        Right gs -> do
            check_res <- checkGSCorrect infconfig lhconfig ghci gs
            case check_res of
                Safe -> return res
                _ -> error "inferenceCheck: Check failed"
        _ -> return res

inference :: InferenceConfig -> G2.Config -> [FilePath] -> [FilePath] -> [FilePath] -> IO (Either [CounterExample] GeneratedSpecs)
inference infconfig config proj fp lhlibs = do
    -- Initialize LiquidHaskell
    (ghci, lhconfig) <- getGHCI infconfig config proj fp lhlibs
    inference' infconfig config lhconfig ghci proj fp lhlibs

inference' :: InferenceConfig -> G2.Config -> LH.Config -> [GhcInfo] -> [FilePath] -> [FilePath] -> [FilePath] -> IO (Either [CounterExample] GeneratedSpecs)
inference' infconfig config lhconfig ghci proj fp lhlibs = do
    mapM (print . gsQualifiers . spec) ghci

    -- Initialize G2
    let g2config = config { mode = Liquid
                          , steps = 2000 }
        transConfig = simplTranslationConfig { simpl = False }
    exg2@(main_mod, _) <- translateLoaded proj fp lhlibs transConfig g2config

    let simp_s = initSimpleState (snd exg2)
        (g2config', infconfig') = adjustConfig main_mod simp_s g2config infconfig ghci

        lrs = createStateForInference simp_s g2config' ghci

        eenv = expr_env . state . lr_state $ lrs

        asserts_on = map (\(Name n m _ _) -> (n, m)) 
                   . map varToName
                   $ concatMap (map fst . gsTySigs . spec) ghci
        asserts_on' = filter (\(Name n m _ _) -> (n, m) `elem` asserts_on ) $ E.keys eenv

        nls = filter (not . null)
            . map (filter (\(Name _ m _ _) -> m == fst exg2)) 
            . nameLevels asserts_on'
            . getCallGraph $ eenv

    putStrLn $ "nls = " ++ show nls

    let configs = Configs { g2_config = g2config', lh_config = lhconfig, inf_config = infconfig'}
    let infL = inferenceL 0 ghci (fst exg2) lrs nls WorkDown emptyGS emptyGS emptyFC emptyFC []

    inf <- runConfigs infL configs
    case inf of
        CEx cex -> return $ Left cex
        GS gs -> return $ Right gs
        FCs _ _ _ _ -> error "inference: Unhandled Func Constraints"

getGHCI :: InferenceConfig -> G2.Config -> [FilePath] -> [FilePath] -> [FilePath] -> IO ([GhcInfo], LH.Config)
getGHCI infconfig config proj fp lhlibs = do
    lhconfig <- defLHConfig proj lhlibs
    let lhconfig' = lhconfig { pruneUnsorted = True
                             -- Block qualifiers being auto-generated by LH
                             , maxParams = if keep_quals infconfig then maxParams lhconfig else 0
                             , eliminate = if keep_quals infconfig then eliminate lhconfig else FP.All
                             , higherorderqs = False
                             , scrapeImports = False
                             , scrapeInternals = False
                             , scrapeUsedImports = False }
    ghci <- ghcInfos Nothing lhconfig' fp
    return (ghci, lhconfig)

data InferenceRes = CEx [CounterExample]
                  | FCs FuncConstraints RisingFuncConstraints WorkingDir LowerGeneratedSpecs
                  | GS GeneratedSpecs
                  deriving (Show)

data WorkingDir = WorkDown | WorkUp deriving (Eq, Show, Read)

-- When we try to synthesize a specification for a function that we have already found a specification for,
-- we have to return to when we originally synthesized that specification.  We pass the newly aquired
-- FuncConstraints as RisignFuncConstraints
type RisingFuncConstraints = FuncConstraints

type LowerGeneratedSpecs = GeneratedSpecs

type Level = Int
type NameLevels = [[Name]]

inferenceL :: (InfConfigM m, MonadIO m) =>  Level -> [GhcInfo] -> Maybe T.Text -> LiquidReadyState
           -> NameLevels -> WorkingDir -> GeneratedSpecs -> LowerGeneratedSpecs -> FuncConstraints -> RisingFuncConstraints -> [Name] -> m InferenceRes
inferenceL level ghci m_modname lrs nls wd gs lower_gs fc rising_fc try_to_synth = do
    liftIO $ putStrLn $ "---\ninference' level " ++ show level
    liftIO . putStrLn $ "at_level = " ++ show (case nls of (h:_) -> Just h; _ -> Nothing)
    liftIO . putStrLn $ "working dir = " ++ show wd
    liftIO . putStrLn $ "try_to_synth = "  ++ show try_to_synth
    liftIO . putStrLn $ "fc =\n" ++ printFCs fc
    liftIO . putStrLn $ "rising_fc =\n" ++ printFCs rising_fc
    liftIO . putStrLn $ "gs =\n" ++ show gs
    liftIO . putStrLn $ "lower_gs =\n" ++ show lower_gs
    liftIO . putStrLn $ "in ghci specs = " ++ show (concatMap (map fst) $ map (gsTySigs . spec) ghci)
    liftIO . putStrLn $ "nls = " ++ show nls

    let (ls1, ls2, ls_rest) = case nls of
                        (ls1':ls2':ls_rest') -> (ls1', ls2', ls_rest')
                        (ls1':[]) -> (ls1', [], [])
                        _ -> ([], [], [])

    let new_lower_gs = filterOutSpecs ls1 lower_gs

    synth_gs <- synthesize ghci lrs gs (unionFC fc rising_fc) try_to_synth

    let ignore = case nls of
                    (_:nls') -> concat nls'
                    [] -> []

    res <- tryHardToVerifyIgnoring ghci (switchAssumesToAsserts synth_gs) (switchAssumesToAsserts new_lower_gs) ignore

    case res of
        Right new_gs
            | (_:nls') <- nls -> do
                liftIO $ putStrLn "---\nFound good GS"
                let new_gs' = switchAssumesToAsserts new_gs
                    ghci' = addSpecsToGhcInfos ghci new_gs'
                
                raiseFCs level ghci m_modname lrs nls wd new_gs fc rising_fc
                    =<< inferenceL (level + 1) ghci' m_modname lrs nls' WorkDown new_gs' new_lower_gs fc rising_fc []
            | otherwise -> return $ GS new_gs
        Left bad -> do
            ref <- refineUnsafe ghci m_modname lrs wd (unionDroppingGS synth_gs new_lower_gs) bad
            
            case ref of
                Left cex -> return $ CEx cex
                Right (new_fc, wd')  -> do
                    liftIO $ putStrLn "---\nNew FuncConstraints"
                    liftIO . putStrLn $ "new_fc =\n" ++ printFCs new_fc
                    let pre_solved = notAppropFCs (ls2 ++ concat ls_rest) new_fc-- alreadySpecified ghci new_fc
                    case nullFC pre_solved of
                        False -> do
                            liftIO . putStrLn $ "---\nreturning FuncConstraints from level " ++ show level
                            -- putStrLn $ "pre_solved =\n" ++ printFCs pre_solved
                            -- putStrLn $ "rising_fc =\n" ++ printFCs rising_fc
                            let merged_pre_fc = unionFC new_fc rising_fc
                                merged_pre_fc' = adjustOldFC merged_pre_fc new_fc
                                fc' = adjustOldFC fc pre_solved
                            return $ FCs fc' merged_pre_fc' wd' (unionDroppingGS synth_gs new_lower_gs)
                        True -> do
                            let fc' = adjustOldFC fc new_fc -- (unionFC rising_fc new_fc)
                                merged_fc = unionFC (unionFC fc' new_fc) rising_fc

                            liftIO $ putStrLn "---\nTrue Branch"
                            -- putStrLn $ "fc' =\n" ++ printFCs fc'
                            -- putStrLn $ "rising_fc =\n" ++ printFCs rising_fc
                            let immed_rel_new = appropFCs ls2 new_fc
                            rel_funcs <- relFuncs immed_rel_new
                            
                            raiseFCs level ghci m_modname lrs nls wd' synth_gs merged_fc emptyFC
                                =<<  inferenceL level ghci m_modname lrs nls wd' synth_gs new_lower_gs merged_fc emptyFC rel_funcs

raiseFCs :: (InfConfigM m, MonadIO m) =>  Level -> [GhcInfo] -> Maybe T.Text -> LiquidReadyState
         -> NameLevels -> WorkingDir -> GeneratedSpecs -> FuncConstraints -> RisingFuncConstraints -> InferenceRes -> m InferenceRes
raiseFCs level ghci m_modname lrs nls wd gs fc rising_fc lev@(FCs fc' new_fc _ new_lower_gs') = do
    liftIO . putStrLn $ "---\nMoving up to level " ++ show level 
    liftIO . putStrLn $ "fc =\n" ++ printFCs fc
    liftIO . putStrLn $ "in ghci specs = " ++ show (concatMap (map fst) $ map (gsTySigs . spec) ghci)
    liftIO . putStrLn $ "rising_fc =\n" ++ printFCs rising_fc
    liftIO . putStrLn $ "new_fc =\n" ++ printFCs new_fc
    let
        (ls2, ls_rest) = case nls of
                            (_:ls2':ls_rest') -> (ls2', ls_rest')
                            _ -> ([], [])

        -- If we have new FuncConstraints, we need to resynthesize,
        -- but otherwise we can just keep the exisiting specifications
        -- cons_on = map (funcName . constraint) $ toListFC new_fc
        immed_rel_new = appropFCs ls2 new_fc
    rel_funcs <- relFuncs immed_rel_new

    let usable_gs = filterOutSpecs (concat ls_rest) gs              


    liftIO $ print ls2                  

    if nullFC (notAppropFCs (ls2 ++ concat ls_rest) new_fc)-- (alreadySpecified ghci new_fc)
        then inferenceL level ghci m_modname lrs nls WorkUp usable_gs new_lower_gs' fc' (unionFC new_fc rising_fc) rel_funcs -- cons_on
        else return lev
raiseFCs _ _ _ _ _ _ _ _ _ lev = do
    liftIO $ putStrLn "---\nReturn lev"
    return lev

appropFCs :: [Name] -> FuncConstraints -> FuncConstraints
appropFCs potential =
    let
        nm_potential = map nameMod potential
    in
    filterFC (flip elem nm_potential . nameMod . funcName . constraint)
    where
        nameMod (Name n m _ _) = (n, m)

notAppropFCs :: [Name] -> FuncConstraints -> FuncConstraints
notAppropFCs potential =
    let
        nm_potential = map nameMod potential
    in
    filterFC (flip notElem nm_potential . nameMod . funcName . constraint)
    where
        nameMod (Name n m _ _) = (n, m)

refineUnsafe :: (InfConfigM m, MonadIO m) => [GhcInfo] -> Maybe T.Text -> LiquidReadyState
             -> WorkingDir -> GeneratedSpecs
             -> [Name] -> m (Either [CounterExample] (FuncConstraints, WorkingDir))
refineUnsafe ghci m_modname lrs wd gs bad = do
    liftIO . putStrLn $ "refineUnsafe " ++ show bad
    liftIO $ print wd
    let merged_se_ghci = addSpecsToGhcInfos ghci (switchAssumesToAsserts gs)

    liftIO $ putStrLn "gsTySigs"
    liftIO $ mapM_ (print . gsTySigs . spec) merged_se_ghci

    let bad' = nub $ map nameOcc bad

    res <- mapM (genNewConstraints merged_se_ghci m_modname lrs) bad'

    liftIO . putStrLn $ "length res = " ++ show (length res)
    liftIO . putStrLn $ "res"
    liftIO . printCE $ concat res
    let res' = concat res

    -- Check if we already have specs for any of the functions
    wd' <- adjustWorkingUp res' wd

    -- Either converts counterexamples to FuncConstraints, or returns them as errors to
    -- show to the user.
    new_fc <- checkNewConstraints ghci lrs wd' res'

    case new_fc of
        Left cex -> return $ Left cex
        Right new_fc' -> do
            return $ Right (new_fc', wd')
                    
adjustOldFC :: FuncConstraints -- ^ Old FuncConstraints
            -> FuncConstraints -- ^ New FuncConstraints
            -> FuncConstraints
adjustOldFC old_fc new_fc =
    let
        constrained = map (funcName . constraint) $ toListFC new_fc
    in
    mapMaybeFC
        (\c -> case modification c of
                    SwitchImplies ns
                        | ns `intersect` constrained /= [] ->
                            Just $ c { bool_rel = BRImplies }
                    Delete ns
                        | ns `intersect` constrained /= [] -> Nothing
                    _ -> Just c) old_fc

createStateForInference :: SimpleState -> G2.Config -> [GhcInfo] -> LiquidReadyState
createStateForInference simp_s config ghci =
    let
        (simp_s', ph_tyvars) = if add_tyvars config
                                then fmap Just $ addTyVarsEEnvTEnv simp_s
                                else (simp_s, Nothing)
        (s, b) = initStateFromSimpleState simp_s' True 
                    (\_ ng _ _ _ _ -> (Prim Undefined TyBottom, [], [], ng))
                    (\_ -> [])
                    config
    in
    createLiquidReadyState s b ghci ph_tyvars config


genNewConstraints :: (InfConfigM m, MonadIO m) => [GhcInfo] -> Maybe T.Text -> LiquidReadyState -> T.Text -> m [CounterExample]
genNewConstraints ghci m lrs n = do
    liftIO . putStrLn $ "Generating constraints for " ++ T.unpack n
    ((exec_res, _), i) <- runLHInferenceCore n m lrs ghci
    return $ map (lhStateToCE i) exec_res

checkNewConstraints :: (InfConfigM m, MonadIO m) => [GhcInfo] -> LiquidReadyState -> WorkingDir -> [CounterExample] -> m (Either [CounterExample] FuncConstraints)
checkNewConstraints ghci lrs wd cexs = do
    g2config <- g2ConfigM
    infconfig <- infConfigM
    res <- mapM (cexsToFuncConstraints lrs ghci wd) cexs
    case lefts res of
        res'@(_:_) -> return . Left $ res'
        _ -> return . Right . filterErrors . unionsFC . rights $ res

alreadySpecified :: [GhcInfo] -> FuncConstraints -> FuncConstraints
alreadySpecified ghci = filterFC (flip isPreRefined ghci . funcName . constraint)

genMeasureExs :: (InfConfigM m, MonadIO m) => LiquidReadyState -> [GhcInfo] -> FuncConstraints -> m MeasureExs
genMeasureExs lrs ghci fcs =
    let
        es = concatMap (\fc ->
                    let
                        cons = constraint fc
                        ex_poly = concat . concatMap extractValues . concatMap extractExprPolyBound $ returns cons:arguments cons
                    in
                    returns cons:arguments cons ++ ex_poly
                ) (toListFC fcs)
    in
    evalMeasures lrs ghci es


synthesize :: (InfConfigM m, MonadIO m) => [GhcInfo] -> LiquidReadyState
            -> GeneratedSpecs -> FuncConstraints -> [Name] -> m GeneratedSpecs
synthesize ghci lrs gs fc for_funcs = do
    -- Only consider functions in the modules that we have access to.
    liftIO $ putStrLn "Before genMeasureExs"
    meas_ex <- genMeasureExs lrs ghci fc
    liftIO $ putStrLn "After genMeasureExs"
    foldM (synthesize' ghci lrs meas_ex fc) gs $ nub for_funcs

synthesize' :: (InfConfigM m, MonadIO m) => [GhcInfo] -> LiquidReadyState -> MeasureExs -> FuncConstraints -> GeneratedSpecs -> Name -> m GeneratedSpecs
synthesize' ghci lrs meas_ex fc gs n = do
    spec_qual <- refSynth ghci lrs meas_ex fc n

    case spec_qual of
        Just (new_spec, new_qual) -> do
            -- We ASSUME postconditions, and ASSERT preconditions.  This ensures
            -- that our precondition is satisified by the caller, and the postcondition
            -- is strong enough to allow verifying the caller
            let gs' = insertNewSpec n new_spec gs

            return $ foldr insertQualifier gs' new_qual
        Nothing -> return gs

synthesizePre :: (InfConfigM m, MonadIO m) => [GhcInfo] -> LiquidReadyState -> MeasureExs -> FuncConstraints -> GeneratedSpecs -> Name -> m GeneratedSpecs
synthesizePre ghci lrs meas_ex fc gs n = do
    spec_qual <- refSynth ghci lrs meas_ex fc n

    case spec_qual of
        Just (new_spec, new_qual) -> do
            -- When we are trying to find a precondition to prevent some bad call,
            -- we want to avoid asserting the precondition, as this will cause us
            -- to move on before we are ready
            let gs' = insertAssumeGS n new_spec gs

            return $ foldr insertQualifier gs' new_qual
        Nothing -> return gs

-- | Converts counterexamples into constraints that the refinements must allow for, or rule out.
cexsToFuncConstraints :: InfConfigM m => LiquidReadyState -> [GhcInfo] -> WorkingDir -> CounterExample -> m (Either CounterExample FuncConstraints)
cexsToFuncConstraints _ _ _ (DirectCounter dfc fcs@(_:_)) = do
    infconfig <- infConfigM
    let fcs' = filter (\fc -> abstractedMod fc `S.member` modules infconfig) fcs
    if not . null $ fcs'
        then return . Right . insertsFC
                            $ mapMaybe (mkRealFCFromAbstracted imp) fcs'
                                       ++ mapMaybe (mkAbstractFCFromAbstracted del) fcs'
        else error "cexsToFuncConstraints: unhandled 1"
    where
        imp = SwitchImplies [funcName dfc]
        del = Delete [funcName dfc]
cexsToFuncConstraints _ _ _ (CallsCounter dfc cfc fcs@(_:_)) = do
    infconfig <- infConfigM
    let fcs' = filter (\fc -> abstractedMod fc `S.member` modules infconfig) fcs
    if not . null $ fcs' 
        then return . Right . insertsFC
                            $ maybeToList (mkRealFCFromAbstracted imp cfc)
                                    ++ mapMaybe (mkRealFCFromAbstracted imp) fcs'
                                    ++ mapMaybe (mkAbstractFCFromAbstracted del) fcs'
        else error "cexsToFuncConstraints: Should be unreachable! Non-refinable function abstracted!"
    where
        imp = SwitchImplies [funcName dfc, funcName $ abstract cfc]
        del = Delete [funcName dfc, funcName $ abstract cfc]
cexsToFuncConstraints lrs ghci _ cex@(DirectCounter fc []) = do
    let Name n m _ _ = funcName fc
    infconfig <- infConfigM
    case (n, m) `S.member` pre_refined infconfig of
        False ->
            return . Right . insertsFC $
                                [FC { polarity = if notRetError fc then Pos else Neg
                                    , violated = Post
                                    , modification = SwitchImplies [funcName fc]
                                    , bool_rel = BRImplies
                                    , constraint = fc} ]
        True -> return . Left $ cex
cexsToFuncConstraints lrs ghci wd cex@(CallsCounter caller_fc called_fc []) = do
    caller_pr <- hasUserSpec (funcName caller_fc)
    called_pr <- hasUserSpec (funcName $ real called_fc)

    case (caller_pr, called_pr) of
        (True, True) -> return .  Left $ cex
        (False, True) ->  return . Right . insertsFC $
                                                  [FC { polarity = Neg
                                                  , violated = Pre
                                                  , modification = None -- [funcName called_fc]
                                                  , bool_rel = BRImplies 
                                                  , constraint = caller_fc } ]
        (True, False) -> return . Right . insertsFC $
                                                 [FC { polarity = if notRetError (real called_fc) then Pos else Neg
                                                 , violated = Pre
                                                 , modification = None -- [funcName caller_fc]
                                                 , bool_rel = if notRetError (real called_fc) then BRAnd else BRImplies
                                                 , constraint = real called_fc } ]
        (False, False)
            | wd == WorkUp -> 
                           return . Right . insertsFC $
                                                    [ FC { polarity = Neg
                                                    , violated = Pre
                                                    , modification = Delete [funcName caller_fc]
                                                    , bool_rel = BRImplies
                                                    , constraint = caller_fc {returns = Prim Error TyBottom} }
                                                    , FC { polarity = if notRetError caller_fc then Pos else Neg
                                                         , violated = Pre
                                                         , modification = None
                                                         , bool_rel = BRImplies
                                                         , constraint = caller_fc }  ]
            | otherwise -> return . Right . insertsFC $
                                                   [FC { polarity = if notRetError (real called_fc) then Pos else Neg
                                                       , violated = Pre
                                                       , modification = SwitchImplies [funcName caller_fc]
                                                       , bool_rel = if notRetError (real called_fc) then BRAnd else BRImplies
                                                       , constraint = real called_fc } ]

mkRealFCFromAbstracted :: Modification -> Abstracted -> Maybe FuncConstraint
mkRealFCFromAbstracted md ce
    | not $ hits_lib_err_in_real ce =
        let
            fc = real ce
        in
        Just $ FC { polarity = if notRetError fc then Pos else Neg
                  , violated = Post
                  , modification = md
                  , bool_rel = if notRetError fc then BRAnd else BRImplies
                  , constraint = fc }
    | otherwise = Nothing 

-- | If the real fc returns an error, we know that our precondition has to be
-- strengthened to block the input.
-- Thus, creating an abstract counterexample would be (at best) redundant.
mkAbstractFCFromAbstracted :: Modification -> Abstracted -> Maybe FuncConstraint
mkAbstractFCFromAbstracted md ce
    | notRetError (real ce) || hits_lib_err_in_real ce =
        let
            fc = abstract ce
        in
        Just $ FC { polarity = Neg
                  , violated = Post
                  , modification = md
                  , bool_rel = BRImplies
                  , constraint = fc } 
    | otherwise = Nothing

isPreRefined :: Name -> [GhcInfo] -> Bool
isPreRefined (Name n m _ _) ghci =
    let
        pre_r = map (varToName . fst) . concatMap (gsTySigs . spec) $ ghci
    in
    any (\(Name n' m' _ _) -> n == n' && m == m' ) pre_r

hasUserSpec :: InfConfigM m => Name -> m Bool
hasUserSpec (Name n m _ _) = do
    infconfig <- infConfigM
    return $ (n, m) `S.member` pre_refined infconfig

adjustWorkingUp :: InfConfigM m => [CounterExample] -> WorkingDir -> m WorkingDir
adjustWorkingUp cexs wd = do
    let
        callers = mapMaybe getDirectCaller cexs
        called = mapMaybe getDirectCalled cexs

    caller_pr <- anyM (hasUserSpec . funcName) callers
    called_pr <- anyM (hasUserSpec . funcName) called
    
    case (caller_pr, called_pr) of
        (True, False) -> return WorkDown
        (False, True) -> return WorkUp
        (_, _)
            | any (isError . returns ) called -> return WorkUp
            | otherwise -> return wd
    where
        isError (Prim Error _) = True
        isError _ = False

anyM :: (Monad m) => (a -> m Bool) -> [a] -> m Bool
anyM _ []       = return False
anyM p (x:xs)   = do
        q <- p x
        if q
                then return True
                else anyM p xs

-- adjustWorkingUp :: InfConfigM m => [CounterExample] -> WorkingUp -> m WorkingUp
-- adjustWorkingUp cexs wu = do
--     wu' <- foldM (addWorkingUp) wu cexs
--     let
--         call_in_wu = filter (\x -> case getDirectCalled x of
--                                         Just n -> memberWU n wu'
--                                         Nothing -> False) cexs
--         callers = mapMaybe getDirectCaller call_in_wu
--         called = mapMaybe getDirectCalled call_in_wu
    
--     return $ foldr deleteWU (foldr insertWU wu' callers) called

addWorkingUp :: InfConfigM m => WorkingUp -> CounterExample -> m WorkingUp
addWorkingUp wu (CallsCounter caller_fc called_fc []) = do
    caller_pr <- hasUserSpec (funcName caller_fc)
    called_pr <- hasUserSpec (funcName $ abstract called_fc)

    case (caller_pr, called_pr) of
        (False, True) -> return $ insertWU (funcName caller_fc) wu
        _ -> return wu
addWorkingUp wu _ = return wu

getDirectCaller :: CounterExample -> Maybe FuncCall
getDirectCaller (CallsCounter f _ []) = Just f
getDirectCaller _ = Nothing

getDirectCalled :: CounterExample -> Maybe FuncCall
getDirectCalled (CallsCounter _ f []) = Just (abstract f)
getDirectCalled _ = Nothing

-- If g is in WorkingUp, but not in the list of names, remove g from WorkingUp,
-- but add all functions that call g that are in the list of names.
-- adjustWorkingUp :: InferenceConfig -> CallGraph -> [Name] -> WorkingUp -> WorkingUp
-- adjustWorkingUp infconfig cg ns wu =
--     let
--         ns' = map zeroOut ns

--         diff = S.toList (allMembers wu) \\ ns'

--         cb = concatMap (flip calledBy cg) diff
--     in
--     trace ("diff = " ++ show ) 
--     foldr insertWU (foldr deleteWU wu diff) cb
--     where
--         zeroOut (Name n m _ l) = Name n m 0 l

-- adjustWorkingUp ::  InferenceConfig -> CounterExample -> WorkingUp -> WorkingUp
-- adjustWorkingUp infconfig (CallsCounter caller_fc called_fc []) wd =
--     let 
--         caller_pr = hasUserSpec (funcName caller_fc) infconfig
--         called_pr = hasUserSpec (funcName called_fc) infconfig
--     in
--     case (caller_pr, called_pr) of
--         (True, False) -> wd
--         (False, False)
--             | (funcName called_fc) `memberWorkUp` wd ->
--                     insertQueueWorkUp (funcName called_fc) wd
--             | otherwise -> insertQueueWorkUp (funcName called_fc) wd
--         _ -> wd 
-- adjustWorkingUp _ _ wd = wd

-- adjustWorkingUp :: InferenceConfig -> CounterExample -> WorkingUp -> WorkingUp
-- adjustWorkingUp infconfig (CallsCounter caller_fc called_fc []) wu =
--     let 
--         caller_pr = isPreRefined (funcName caller_fc) infconfig
--         called_pr = isPreRefined (funcName called_fc) infconfig
--     in
--     case (caller_pr, called_pr) of
--         (True, False) -> S.empty -- wu -- TODO
--         (False, False)
--             | nameOcc (funcName called_fc) `S.member` wu ->
--                     S.insert (nameOcc $ funcName called_fc) wu
--             | otherwise -> S.insert (nameOcc $ funcName called_fc) wu
--         _ -> wu 
-- adjustWorkingUp _ _ wu = wu

-- isPreRefined :: Name -> InferenceConfig -> Bool
-- isPreRefined (Name n m _ _) infconfig = (n, m) `S.member` pre_refined infconfig

getBoolRel :: FuncCall -> FuncCall -> BoolRel
getBoolRel fc1 fc2 =
    if notSameFunc fc1 fc2 && notRetError fc2 then BRAnd else BRImplies

notSameFunc :: FuncCall -> FuncCall -> Bool
notSameFunc fc1 fc2 = nameOcc (funcName fc1) /= nameOcc (funcName fc2)

notRetError :: FuncCall -> Bool
notRetError (FuncCall { returns = Prim Error _ }) = False
notRetError _ = True

insertsFC :: [FuncConstraint] -> FuncConstraints
insertsFC = foldr insertFC emptyFC

abstractedMod :: Abstracted -> Maybe T.Text
abstractedMod = nameModule . funcName . abstract

filterErrors :: FuncConstraints -> FuncConstraints
filterErrors = filterFC filterErrors'

filterErrors' :: FuncConstraint -> Bool
filterErrors' fc =
    let
        c = constraint fc

        as = not . any isError $ arguments c
        r = not . isError . returns $ c
    in
    as -- && (r || FC.violated fc == Pre)
    where
        isError (Prim Error _) = True
        isError _ = False


relFuncs :: InfConfigM m => FuncConstraints -> m [Name]
relFuncs fc = do
    infconfig <- infConfigM
    return 
       . filter (\(Name _ m _ _) -> m `S.member` (modules infconfig))
       . nubBy (\n1 n2 -> nameOcc n1 == nameOcc n2)
       . map (funcName . constraint)
       . toListFC $ fc

-- -- | Checks if we found an incorrect specification higher in the tree,
-- -- and if so indicates which function(s) were incorrectly guessed
-- madeWrongGuesses :: [CounterExample] -> [Name]
-- madeWrongGuesses = mapMaybe madeWrongGuess

-- madeWrongGuess :: CounterExample -> Maybe Name
-- madeWrongGuess (DirectCounter f []) = Just $ funcName f
-- madeWrongGuess (CallsCounter caller_f _ []) = Just $ funcName caller_f
-- madeWrongGuess _ = Nothing

-- -- Go back and try to reverify all functions that call the passed function
-- correctWrongGuessesInFC :: [Name] -> FuncConstraints -> FuncConstraints
-- correctWrongGuessesInFC ns =
--     mapFC (\fc -> if funcName (constraint fc) `elem` ns
--                     then fc { bool_rel = BRImplies}
--                     else fc)


-- correctWrongGuessesInGS :: [Name] -> CallGraph -> GeneratedSpecs -> GeneratedSpecs
-- correctWrongGuessesInGS ns cg gs =
--     foldr (\n -> correctWrongGuessInGS n cg) gs $ nub ns

-- correctWrongGuessInGS :: Name -> CallGraph -> GeneratedSpecs -> GeneratedSpecs
-- correctWrongGuessInGS n g gs =
--     trace ("wrong guess = " ++ show n)
--     deleteAssert n . deleteAssume n
--         $ foldr (\n -> moveAssertToSpec) gs $ calledBy n g
--     where
--         moveAssertToSpec
--             | Just s <- lookupAssertGS n gs = insertNewSpec n s
--             | otherwise = id


-------

getGoodCalls :: InferenceConfig -> G2.Config -> LH.Config -> [GhcInfo] -> Maybe T.Text -> LiquidReadyState -> IO [FuncCall]
getGoodCalls infconfig config lhconfig ghci m_mod lrs = do
    let es = map (\(Name n m _ _) -> (n, m)) . E.keys . expr_env . state $ lr_state lrs
        
        cs = map (mkName . varName) $ concatMap (map fst . gsTySigs . spec) ghci
        cs' = filter (\(Name n m _ _) -> (n, m) `elem` es && m == m_mod) cs

        cs'' = map nameOcc cs'

    putStrLn $ "cs'' = " ++ show cs''
    return . concat
        =<< mapM (\c -> gatherAllowedCalls c m_mod lrs ghci infconfig config) cs''

