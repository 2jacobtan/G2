3350
flycheck_List.lhs-2015-03-20T04.19.33.lhs
(198, '28-50')
prop_zipWith
[' /home/gridaphobe/src/liquidhaskell/benchmarks/ucsd/wi15/final/liquid-cache/flycheck_List.lhs-2015-03-20T04.19.33.lhs:198:28-50: Error: Liquid Type Mismatch', ' 198 | prop_zipWith xs = lAssert (length xs == length x2s)']

LiquidHaskell Copyright 2013-17 Regents of the University of California. All Rights Reserved.

[1;94m
**** DONE:  A-Normalization ****************************************************
[0m[1;90m 
[0mprop_zipWith Emp = error
makes a call to
die (lh lhEqBool lhNeBool lhLtBool lhLeBool lhGtBool lhGeBool lhPPBool) ("Assert Fails!") = error
violating die's refinement type
when
length (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) x2s = 1
Strengthen the refinement type of length to eliminate this possibility
Abstract

prop_zipWith Emp = error
makes a call to
die (lh lhEqBool lhNeBool lhLtBool lhLeBool lhGtBool lhGeBool lhPPBool) ("Assert Fails!") = error
violating die's refinement type
when
length (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) Emp = 1
Strengthen the refinement type of length to eliminate this possibility
Abstract

prop_zipWith (0 :+: Emp) = error
makes a call to
die (lh lhEqBool lhNeBool lhLtBool lhLeBool lhGtBool lhGeBool lhPPBool) ("Assert Fails!") = error
violating die's refinement type
when
length (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) x2s = 2
Strengthen the refinement type of length to eliminate this possibility
Abstract

prop_zipWith (0 :+: Emp) = error
makes a call to
die (lh lhEqBool lhNeBool lhLtBool lhLeBool lhGtBool lhGeBool lhPPBool) ("Assert Fails!") = error
violating die's refinement type
when
zipWith (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) fs? (0 :+: Emp) (0 :+: Emp) = Emp
Strengthen the refinement type of zipWith to eliminate this possibility
Abstract

prop_zipWith Emp = error
makes a call to
die (lh lhEqBool lhNeBool lhLtBool lhLeBool lhGtBool lhGeBool lhPPBool) ("Assert Fails!") = error
violating die's refinement type
when
zipWith (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) fs? Emp Emp = 0 :+: Emp
Strengthen the refinement type of zipWith to eliminate this possibility
Abstract

prop_zipWith (0 :+: Emp) = error
makes a call to
die (lh lhEqBool lhNeBool lhLtBool lhLeBool lhGtBool lhGeBool lhPPBool) ("Assert Fails!") = error
violating die's refinement type
when
length (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (0 :+: Emp) = 2
Strengthen the refinement type of length to eliminate this possibility
Abstract

prop_zipWith (0 :+: (0 :+: Emp)) = error
makes a call to
die (lh lhEqBool lhNeBool lhLtBool lhLeBool lhGtBool lhGeBool lhPPBool) ("Assert Fails!") = error
violating die's refinement type
when
length (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) x2s = 3
Strengthen the refinement type of length to eliminate this possibility
Abstract

prop_zipWith Emp = error
makes a call to
die (lh lhEqBool lhNeBool lhLtBool lhLeBool lhGtBool lhGeBool lhPPBool) ("Assert Fails!") = error
violating die's refinement type
when
zipWith (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) fs? Emp Emp = 0 :+: (0 :+: Emp)
Strengthen the refinement type of zipWith to eliminate this possibility
Abstract

prop_zipWith (0 :+: (0 :+: Emp)) = error
makes a call to
die (lh lhEqBool lhNeBool lhLtBool lhLeBool lhGtBool lhGeBool lhPPBool) ("Assert Fails!") = error
violating die's refinement type
when
zipWith (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) fs? (0 :+: (0 :+: Emp)) (0 :+: (0 :+: Emp)) = Emp
Strengthen the refinement type of zipWith to eliminate this possibility
Abstract

prop_zipWith Emp = error
makes a call to
die (lh lhEqBool lhNeBool lhLtBool lhLeBool lhGtBool lhGeBool lhPPBool) ("Assert Fails!") = error
violating die's refinement type
when
zipWith (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) fs? Emp Emp = 0 :+: (0 :+: (0 :+: Emp))
Strengthen the refinement type of zipWith to eliminate this possibility
Abstract

prop_zipWith (0 :+: (0 :+: (0 :+: Emp))) = error
makes a call to
die (lh lhEqBool lhNeBool lhLtBool lhLeBool lhGtBool lhGeBool lhPPBool) ("Assert Fails!") = error
violating die's refinement type
when
length (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) x2s = 4
Strengthen the refinement type of length to eliminate this possibility
Abstract

prop_zipWith (0 :+: Emp) = error
makes a call to
die (lh lhEqBool lhNeBool lhLtBool lhLeBool lhGtBool lhGeBool lhPPBool) ("Assert Fails!") = error
violating die's refinement type
when
zipWith (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) fs? (0 :+: Emp) (0 :+: Emp) = 0 :+: (0 :+: Emp)
Strengthen the refinement type of zipWith to eliminate this possibility
Abstract

prop_zipWith (0 :+: (0 :+: (0 :+: Emp))) = error
makes a call to
die (lh lhEqBool lhNeBool lhLtBool lhLeBool lhGtBool lhGeBool lhPPBool) ("Assert Fails!") = error
violating die's refinement type
when
zipWith (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) fs? (0 :+: (0 :+: (0 :+: Emp))) (0 :+: (0 :+: (0 :+: Emp))) = Emp
Strengthen the refinement type of zipWith to eliminate this possibility
Abstract

prop_zipWith (0 :+: (0 :+: Emp)) = error
makes a call to
die (lh lhEqBool lhNeBool lhLtBool lhLeBool lhGtBool lhGeBool lhPPBool) ("Assert Fails!") = error
violating die's refinement type
when
length (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (0 :+: (0 :+: Emp)) = 3
Strengthen the refinement type of length to eliminate this possibility
Abstract

prop_zipWith (0 :+: (0 :+: Emp)) = error
makes a call to
die (lh lhEqBool lhNeBool lhLtBool lhLeBool lhGtBool lhGeBool lhPPBool) ("Assert Fails!") = error
violating die's refinement type
when
zipWith (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) fs? (0 :+: (0 :+: Emp)) (0 :+: (0 :+: Emp)) = 0 :+: Emp
Strengthen the refinement type of zipWith to eliminate this possibility
Abstract


ERROR:

liquidhaskell-study/wi15/unsafe/flycheck_List.lhs-2015-03-20T04.19.33.lhs:142:1: warning: [-Woverlapping-patterns]
    Pattern match is redundant
    In an equation for â€˜replicateâ€™: replicate n x = ...

liquidhaskell-study/wi15/unsafe/flycheck_List.lhs-2015-03-20T04.19.33.lhs:142:1: warning: [-Woverlapping-patterns]
    Pattern match is redundant
    In an equation for â€˜replicateâ€™: replicate n x = ...

11.246280193328857

LIQUID_OUT:
LiquidHaskell Copyright 2009-15 Regents of the University of California. All Rights Reserved.

[1;94m
**** DONE:  Extracted Core using GHC *******************************************
[0m[1;90m 
[0m[1;94m
**** DONE:  Uniqify & Rename ***************************************************
[0m[1;90m 
[0mRESULT: Unsafe [Just 289,Just 338,Just 355,Just 276,Just 356,Just 310,Just 360,Just 346,Just 252,Just 301]
[1;94m
**** START: pandoc *************************************************************
[0m[1;90m 
[0m[1;94m
**** DONE:  pandoc *************************************************************
[0m[1;90m 
[0m[1;94m
**** START: pandoc *************************************************************
[0m[1;90m 
[0m[1;94m
**** DONE:  pandoc *************************************************************
[0m[1;90m 
[0m[1;94m
**** DONE:  annotate ***********************************************************
[0m[1;90m 
[0m[1;91m
**** RESULT: UNSAFE ************************************************************
[0m

 /home/gridaphobe/src/liquidhaskell/benchmarks/ucsd/wi15/final/liquid-cache/flycheck_List.lhs-2015-03-20T04.19.33.lhs:99:23-36: Error: Liquid Type Mismatch
 
 99 | prop_size  = lAssert (length l3 == 3)
                            ^^^^^^^^^^^^^^
 
   Inferred type
     VV : {VV : Bool | VV == ?a}
  
   not a subtype of Required type
     VV : {VV : Bool | Prop VV}
  
   In Context
     ?c : {?c : Int | ?c >= 0}
      
     ?b : {?b : Int | ?b == (3 : int)}
      
     ?a : {?a : Bool | Prop ?a <=> ?c == ?b}


 /home/gridaphobe/src/liquidhaskell/benchmarks/ucsd/wi15/final/liquid-cache/flycheck_List.lhs-2015-03-20T04.19.33.lhs:141:1-9: Error: Liquid Type Mismatch
 
 141 | replicate n _ = Emp
       ^^^^^^^^^
 
   Inferred type
     VV : {VV : (List a) | size VV == 0
                           && 0 <= size VV}
  
   not a subtype of Required type
     VV : {VV : (List a) | n == size VV}
  
   In Context
     n : {n : Int | n >= 0}


 /home/gridaphobe/src/liquidhaskell/benchmarks/ucsd/wi15/final/liquid-cache/flycheck_List.lhs-2015-03-20T04.19.33.lhs:149:31-57: Error: Liquid Type Mismatch
 
 149 | prop_replicate n x = lAssert (n == length (replicate n x))
                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
   Inferred type
     VV : {VV : Bool | VV == ?a}
  
   not a subtype of Required type
     VV : {VV : Bool | Prop VV}
  
   In Context
     n : {n : Int | n >= 0}
      
     ?b : {?b : Int | ?b >= 0}
      
     ?a : {?a : Bool | Prop ?a <=> n == ?b}


 /home/gridaphobe/src/liquidhaskell/benchmarks/ucsd/wi15/final/liquid-cache/flycheck_List.lhs-2015-03-20T04.19.33.lhs:164:26-55: Error: Liquid Type Mismatch
 
 164 | prop_map f xs = lAssert (length xs == length (map f xs))
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
   Inferred type
     VV : {VV : Bool | VV == ?b}
  
   not a subtype of Required type
     VV : {VV : Bool | Prop VV}
  
   In Context
     ?c : {?c : Int | ?c >= 0}
      
     ?b : {?b : Bool | Prop ?b <=> ?c == ?a}
      
     ?a : {?a : Int | ?a >= 0}


 /home/gridaphobe/src/liquidhaskell/benchmarks/ucsd/wi15/final/liquid-cache/flycheck_List.lhs-2015-03-20T04.19.33.lhs:176:28-63: Error: Liquid Type Mismatch
 
 176 | foldr1 op Emp        = die "Cannot call foldr1 with empty list"
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
   Inferred type
     VV : {VV : [Char] | VV == ?a
                         && len VV >= 0}
  
   not a subtype of Required type
     VV : {VV : [Char] | false}
  
   In Context
     ?b : {?b : Addr# | ?b ~~ "Cannot call foldr1 with empty list"
                        && strLen ?b == 34}
      
     ?a : {?a : [Char] | ?a ~~ ?b
                         && len ?a == strLen ?b
                         && len ?a >= 0}


 /home/gridaphobe/src/liquidhaskell/benchmarks/ucsd/wi15/final/liquid-cache/flycheck_List.lhs-2015-03-20T04.19.33.lhs:195:40-60: Error: Liquid Type Mismatch
 
 195 | zipWith f _          _          = die  "Bad call to zipWith"
                                              ^^^^^^^^^^^^^^^^^^^^^
 
   Inferred type
     VV : {VV : [Char] | VV == ?a
                         && len VV >= 0}
  
   not a subtype of Required type
     VV : {VV : [Char] | false}
  
   In Context
     ?b : {?b : Addr# | ?b ~~ "Bad call to zipWith"
                        && strLen ?b == 19}
      
     ?a : {?a : [Char] | ?a ~~ ?b
                         && len ?a == strLen ?b
                         && len ?a >= 0}


 /home/gridaphobe/src/liquidhaskell/benchmarks/ucsd/wi15/final/liquid-cache/flycheck_List.lhs-2015-03-20T04.19.33.lhs:198:28-50: Error: Liquid Type Mismatch
 
 198 | prop_zipWith xs = lAssert (length xs == length x2s)
                                  ^^^^^^^^^^^^^^^^^^^^^^^
 
   Inferred type
     VV : {VV : Bool | VV == ?c}
  
   not a subtype of Required type
     VV : {VV : Bool | Prop VV}
  
   In Context
     ?c : {?c : Bool | Prop ?c <=> ?a == ?b}
      
     ?b : {?b : Int | ?b >= 0}
      
     ?a : {?a : Int | ?a >= 0}


 /home/gridaphobe/src/liquidhaskell/benchmarks/ucsd/wi15/final/liquid-cache/flycheck_List.lhs-2015-03-20T04.19.33.lhs:214:16-23: Error: Liquid Type Mismatch
 
 214 | concat = fixme "concat"
                      ^^^^^^^^
 
   Inferred type
     VV : {VV : [Char] | VV == ?a
                         && len VV >= 0}
  
   not a subtype of Required type
     VV : {VV : [Char] | false}
  
   In Context
     ?b : {?b : Addr# | ?b ~~ "concat"
                        && strLen ?b == 6}
      
     ?a : {?a : [Char] | ?a ~~ ?b
                         && len ?a == strLen ?b
                         && len ?a >= 0}


 /home/gridaphobe/src/liquidhaskell/benchmarks/ucsd/wi15/final/liquid-cache/flycheck_List.lhs-2015-03-20T04.19.33.lhs:216:24-47: Error: Liquid Type Mismatch
 
 216 | prop_concat = lAssert (length (concat xss) == 6)
                              ^^^^^^^^^^^^^^^^^^^^^^^^
 
   Inferred type
     VV : {VV : Bool | VV == ?c}
  
   not a subtype of Required type
     VV : {VV : Bool | Prop VV}
  
   In Context
     ?c : {?c : Bool | Prop ?c <=> ?a == ?b}
      
     ?b : {?b : Int | ?b == (6 : int)}
      
     ?a : {?a : Int | ?a >= 0}
