3807
flycheck_MapReduce.lhs-2015-03-21T00.03.54.lhs
(32, '21-36')
mapReduce
[' /home/gridaphobe/src/liquidhaskell/benchmarks/ucsd/wi15/final/liquid-cache/flycheck_MapReduce.lhs-2015-03-21T00.03.54.lhs:32:21-36: Error: Liquid Type Mismatch', ' 32 |                then collapse fr kvsm      ']

LiquidHaskell Copyright 2013-17 Regents of the University of California. All Rights Reserved.

[1;94m
**** DONE:  A-Normalization ****************************************************
[0m[1;90m 
[0mmapReduce undefined undefined Emp = error
makes a call to
collapse (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) undefined (fromList ([(0, Emp)])) = fromList (map (lh(,) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lhList (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt))) (lh(,) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt)) \ds1 -> 
   case ds1 of
      (,) k1 v -> (k1, f v) ([(0, Emp)]))
violating collapse's refinement type
when
group (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) kvs = fromList ([(0, Emp)])
Strengthen the refinement type of group to eliminate this possibility
Abstract

mapReduce undefined undefined Emp = error
makes a call to
collapse (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) undefined (fromList ([(0, Emp), (0, Emp)])) = fromList (map (lh(,) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lhList (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt))) (lh(,) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt)) \ds1 -> 
   case ds1 of
      (,) k1 v -> (k1, f v) ([(0, Emp), (0, Emp)]))
violating collapse's refinement type
when
group (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) kvs = fromList ([(0, Emp), (0, Emp)])
Strengthen the refinement type of group to eliminate this possibility
Abstract

mapReduce undefined undefined Emp = error
makes a call to
collapse (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) undefined (fromList ([(0, Emp), (0, Emp), (0, Emp)])) = fromList (map (lh(,) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lhList (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt))) (lh(,) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt)) \ds1 -> 
   case ds1 of
      (,) k1 v -> (k1, f v) ([(0, Emp), (0, Emp), (0, Emp)]))
violating collapse's refinement type
when
group (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) kvs = fromList ([(0, Emp), (0, Emp), (0, Emp)])
Strengthen the refinement type of group to eliminate this possibility
Abstract

mapReduce undefined undefined Emp = error
makes a call to
collapse (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) undefined (fromList ([(0, Emp), (0, Emp), (0, Emp), (0, Emp)])) = fromList (map (lh(,) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lhList (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt))) (lh(,) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt)) \ds1 -> 
   case ds1 of
      (,) k1 v -> (k1, f v) ([(0, Emp), (0, Emp), (0, Emp), (0, Emp)]))
violating collapse's refinement type
when
group (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) kvs = fromList ([(0, Emp), (0, Emp), (0, Emp), (0, Emp)])
Strengthen the refinement type of group to eliminate this possibility
Abstract

mapReduce undefined undefined Emp = error
makes a call to
collapse (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) undefined (fromList ([(0, Emp), (0, Emp), (0, Emp), (0, Emp), (0, Emp)])) = fromList (map (lh(,) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lhList (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt))) (lh(,) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt)) \ds1 -> 
   case ds1 of
      (,) k1 v -> (k1, f v) ([(0, Emp), (0, Emp), (0, Emp), (0, Emp), (0, Emp)]))
violating collapse's refinement type
when
group (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) kvs = fromList ([(0, Emp), (0, Emp), (0, Emp), (0, Emp), (0, Emp)])
Strengthen the refinement type of group to eliminate this possibility
Abstract

mapReduce undefined undefined Emp = error
makes a call to
collapse (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) undefined (fromList ([(0, Emp), (0, Emp), (0, Emp), (0, Emp), (0, Emp), (0, Emp)])) = fromList (map (lh(,) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lhList (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt))) (lh(,) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt)) \ds1 -> 
   case ds1 of
      (,) k1 v -> (k1, f v) ([(0, Emp), (0, Emp), (0, Emp), (0, Emp), (0, Emp), (0, Emp)]))
violating collapse's refinement type
when
group (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) (lh lhEqInt lhNeInt lhLtInt lhLeInt lhGtInt lhGeInt lhPPInt) kvs = fromList ([(0, Emp), (0, Emp), (0, Emp), (0, Emp), (0, Emp), (0, Emp)])
Strengthen the refinement type of group to eliminate this possibility
Abstract


17.51365351676941

LIQUID_OUT:
LiquidHaskell Copyright 2009-15 Regents of the University of California. All Rights Reserved.

[1;94m
**** DONE:  Extracted Core using GHC *******************************************
[0m[1;90m 
[0m[1;94m
**** DONE:  Uniqify & Rename ***************************************************
[0m[1;90m 
[0mRESULT: Unsafe [Just 5]
[1;94m
**** START: pandoc *************************************************************
[0m[1;90m 
[0m[1;94m
**** DONE:  pandoc *************************************************************
[0m[1;90m 
[0m[1;94m
**** START: pandoc *************************************************************
[0m[1;90m 
[0m[1;94m
**** DONE:  pandoc *************************************************************
[0m[1;90m 
[0m[1;94m
**** DONE:  annotate ***********************************************************
[0m[1;90m 
[0m[1;91m
**** RESULT: UNSAFE ************************************************************
[0m

 /home/gridaphobe/src/liquidhaskell/benchmarks/ucsd/wi15/final/liquid-cache/flycheck_MapReduce.lhs-2015-03-21T00.03.54.lhs:32:21-36: Error: Liquid Type Mismatch
 
 32 |                then collapse fr kvsm      -- step 3
                          ^^^^^^^^^^^^^^^^
 
   Inferred type
     VV : {VV : (List a) | 0 <= size VV
                           && 0 <= sizes VV}
  
   not a subtype of Required type
     VV : {VV : (List a) | size VV > 0}
  
   In Context
